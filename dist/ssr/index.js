!function(e,n){for(var t in n)e[t]=n[t]}(exports,function(e){var n={};function t(r){if(n[r])return n[r].exports;var a=n[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var a in e)t.d(r,a,function(n){return e[n]}.bind(null,a));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=32)}([function(e,n){e.exports=require("react")},function(e,n,t){"use strict";var r=t(4),a=(t(38),t(39),t(40),t(41),t(42),t(43),t(44),t(45),t(46),t(0)),o=t.n(a);function i(e){var n=e.value,t=e.language,a=void 0===t?"none":t;["javascript jsx"].indexOf(a)&&(a="jsx"),["typescript jsx"].indexOf(a)&&(a="tsx"),r.languages[a]||(a="none");var i=r.languages[a]?r.languages[a]:r.languages.js,s=Object(r.highlight)(n,i),u="language-"+a;return o.a.createElement("pre",{className:u},o.a.createElement("code",{className:u,dangerouslySetInnerHTML:{__html:s}}))}var s=t(28),u=t.n(s);function l(e){var n=e.text,t=e.children;return o.a.createElement(u.a,{source:n||t,renderers:{code:i}})}t.d(n,"a",function(){return i}),t.d(n,"b",function(){return l})},function(e,n){e.exports=require("react-router")},function(e,n){e.exports=require("react-intl")},function(e,n){e.exports=require("prismjs")},function(e,n){e.exports=require("locale-code")},function(e,n){e.exports=require("react-router-dom")},function(e,n,t){"use strict";t.d(n,"a",function(){return i});var r=t(0);function a(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=[],r=!0,a=!1,o=void 0;try{for(var i,s=e[Symbol.iterator]();!(r=(i=s.next()).done)&&(t.push(i.value),!n||t.length!==n);r=!0);}catch(e){a=!0,o=e}finally{try{r||null==s.return||s.return()}finally{if(a)throw o}}return t}(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function o(e){var n=e.load,t=e.props,o=a(Object(r.useState)(null),2),i=o[0],s=o[1];return Object(r.useEffect)(function(){n.then(function(e){var n=e.default;s(Object(r.createElement)(n,t))})},[]),i}function i(e){return function(n){return Object(r.createElement)(o,{props:n,load:e()})}}},function(e,n,t){"use strict";t.d(n,"a",function(){return l}),t.d(n,"b",function(){return c});var r=t(0),a=t.n(r),o=t(3);function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=Object(r.createContext)(),u=Object(o.injectIntl)(function(e){var n=e.intl,t=e.children;return n,a.a.createElement(s.Provider,{value:n},t)});function l(e){var n=e.children,t=i(e,["children"]);return a.a.createElement(o.IntlProvider,t,a.a.createElement(u,null,n))}function c(){return Object(r.useContext)(s)}},function(e,n){e.exports=require("antd/lib/layout")},function(e,n){e.exports=require("antd/lib/icon")},function(e,n){e.exports=require("antd/lib/menu")},function(e,n){e.exports=require("body-parser")},function(e,n,t){e.exports={header:"index_header__1ePqQ",content:"index_content__8EclH"}},function(e,n){e.exports=require("js-cookie")},function(e,n){},function(e,n,t){"use strict";t(0),t(2),t(7)},function(e,n,t){"use strict";t.d(n,"a",function(){return s});var r=t(0),a=t(2);function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}var s=function e(n){var t=this;!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),this.routes=n,this.preload=function(e){return Promise.resolve()},this.getRoute=function(e){var n=t.routes.find(function(n){return n.path===e});if(n)return Object(r.createElement)(a.Route,function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},r=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.forEach(function(n){i(e,n,t[n])})}return e}({},n,{key:e}));throw new Error("Can't find matched path. ".concat(e))},this.getAllRoutes=function(){return t.routes.map(function(e){var n=e.path;return t.getRoute(n)})},this.getRouteOptions=function(){return t.routes.map(function(e){e.component;return o(e,["component"])})}}},function(e,n,t){"use strict"},function(e,n,t){"use strict";t.r(n);var r=t(9),a=t.n(r),o=(t(33),t(34),t(0)),i=t.n(o);function s(e){var n=e.routeStore;return i.a.createElement(o.Fragment,null,n.getAllRoutes())}var u=t(10),l=t.n(u),c=t(11),p=t.n(c),m=t(6),d=t(23),b=t.n(d),x=p.a.Item,f=p.a.SubMenu;function g(){var e=b()().location,n=Object(o.useMemo)(function(){return[e.pathname]},[e.pathname]);return i.a.createElement(p.a,{mode:"horizontal",selectedKeys:n,style:{lineHeight:"64px"}},i.a.createElement(x,{key:"/"},i.a.createElement(m.Link,{to:"/"},i.a.createElement(l.a,{type:"home"}))),i.a.createElement(f,{key:"/modules",title:i.a.createElement("span",null,i.a.createElement(l.a,{type:"tool"}),i.a.createElement("span",null,"Modules"))},["react-devdoc","react-router-store","use-react-intl","use-locale","use-timezone"].map(function(e){return i.a.createElement(x,{key:"/modules/"+e},i.a.createElement(m.Link,{to:"/modules/"+e},e))})),i.a.createElement(f,{key:"/research",title:i.a.createElement("span",null,i.a.createElement(l.a,{type:"experiment"}),i.a.createElement("span",null,"Research"))},["immer","numeral"].map(function(e){return i.a.createElement(x,{key:"/research/"+e},i.a.createElement(m.Link,{to:"/research/"+e},e))}),["immutable"].map(function(e){return i.a.createElement(x,{key:"/research/"+e},i.a.createElement(m.Link,{to:"/research/"+e},i.a.createElement("s",null,e)))})))}t(35);var y=t(13),h=t.n(y),S=a.a.Content,v=a.a.Header;function q(e){var n=e.routeStore;return i.a.createElement(a.a,null,i.a.createElement(v,{className:h.a.header},i.a.createElement(g,null)),i.a.createElement(S,{className:h.a.content},i.a.createElement(s,{routeStore:n})))}var E=t(24),k=t(3),C=t(25),L=t.n(C),T=t(26),w=t.n(T),I=t(14),B=t(5),j=t.n(B);function M(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=[],r=!0,a=!1,o=void 0;try{for(var i,s=e[Symbol.iterator]();!(r=(i=s.next()).done)&&(t.push(i.value),!n||t.length!==n);r=!0);}catch(e){a=!0,o=e}finally{try{r||null==s.return||s.return()}finally{if(a)throw o}}return t}(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function z(e){var n=M(Object(o.useState)(e),2),t=n[0],r=n[1];return{locale:t,updateLocale:Object(o.useCallback)(function(e){j.a.validate(e)&&(r(e),function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"locale";j.a.validate(e)&&Object(I.set)(n,e)}(e))},[])}}var R=t(8);Object(k.addLocaleData)(L.a),Object(k.addLocaleData)(w.a);var P,A=Object(o.createContext)();function K(e){var n=e.children,t=z(e.currentLocale),r=t.locale,a=t.updateLocale;return i.a.createElement(R.a,{locale:r.slice(0,2),messages:E[r]},i.a.createElement(A.Provider,{value:{locale:r,updateLocale:a}},n))}!function(e){e.locale="locale",e.timezone="timezone"}(P||(P={}));var O=new(t(27).SyncRouteStore)([{path:"/",exact:!0,component:t(36).default},{path:"/modules/react-devdoc",component:t(37).default},{path:"/modules/react-router-store",component:t(48).default},{path:"/modules/use-locale",component:t(50).default},{path:"/modules/use-react-intl",component:t(52).default},{path:"/modules/use-timezone",component:t(54).default},{path:"/research/immer",component:t(56).default},{path:"/research/immutable",component:t(59).default},{path:"/research/numeral",component:t(68).default}]),J=t(29),V=t(30),_=t(2),N=t(31),$=t.n(N);function F(e,n){n.send(function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=e.cookies[P.locale]||"en-US",r=Object(V.renderToString)(i.a.createElement(_.StaticRouter,{location:e.url,context:{}},i.a.createElement(K,{currentLocale:t},i.a.createElement(q,{routeStore:O}))));return Object(J.render)($.a,{base:"/",body:r,initialState:JSON.stringify(n)})}(e))}t.d(n,"requestHandler",function(){return F})},function(e,n){e.exports=require("cookie-parser")},function(e,n){e.exports=require("express")},function(e,n){e.exports=require("moment-timezone")},function(e,n){e.exports=require("use-react-router")},function(e){e.exports={"en-US":{"app.main.text":"Main"},"ko-KR":{"app.main.text":"메인"}}},function(e,n){e.exports=require("react-intl/locale-data/en")},function(e,n){e.exports=require("react-intl/locale-data/ko")},function(e,n,t){"use strict";var r=t(15);t.o(r,"SyncRouteStore")&&t.d(n,"SyncRouteStore",function(){return r.SyncRouteStore});t(16);var a=t(17);t.d(n,"SyncRouteStore",function(){return a.a});t(7),t(18)},function(e,n){e.exports=require("react-markdown")},function(e,n){e.exports=require("ejs")},function(e,n){e.exports=require("react-dom/server")},function(e,n){e.exports='<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=UTF-8>\n    <meta name="viewport" content="width=device-width, initial-scale=1">\n    <base href="/"/>\n    <link rel="stylesheet" type="text/css" href="vendor.css"/>\n    <link rel="stylesheet" type="text/css" href="style.css"/>\n    <title>SSENKIT</title>\n    <% if (locals.initialState) { %>\n      <script>\n        window.__INITIAL_STATE__ = <%- locals.initialState.replace(/</g, \'\\\\u003c\'); %>\n      <\/script>\n    <% } %>\n  </head>\n  \n  <body>\n    <div id="app"><%- (locals.body || \'\') %></div>\n  </body>\n  \n  <script src="vendor.js"><\/script>\n  <script src="style.js"><\/script>\n  \x3c!-- And if you use css themes you need require add their js files. --\x3e\n  <script src="app.js"><\/script>\n</html>'},function(e,n,t){"use strict";t.r(n);var r=t(12),a=t.n(r),o=t(20),i=t.n(o),s=t(21),u=t.n(s),l=t(22),c=t.n(l),p=Number(process.env.PORT||4100),m=u()();m.use(a.a.urlencoded({extended:!1})),m.use(a.a.json()),m.use(i()()),m.get("/",t(19).requestHandler),m.get("/*",t(19).requestHandler),m.listen(p,function(){console.log("SSR server started ".concat(p," [").concat(c()().format("HH:mm:ss"),"]"))})},function(e,n,t){},function(e,n,t){},function(e,n,t){},function(e,n,t){"use strict";t.r(n);var r=t(0),a=t.n(r),o=t(8);n.default=function(){var e=Object(o.b)().formatMessage;return a.a.createElement("div",null,e({id:"app.main.text"}))}},function(e,n,t){"use strict";t.r(n);var r=t(0),a=t.n(r),o=t(1);n.default=function(){return a.a.createElement("div",null,a.a.createElement(o.b,{text:t(47)}))}},function(e,n){!function(e){var n={variable:[{pattern:/\$?\(\([\s\S]+?\)\)/,inside:{variable:[{pattern:/(^\$\(\([\s\S]+)\)\)/,lookbehind:!0},/^\$\(\(/],number:/\b0x[\dA-Fa-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee]-?\d+)?/,operator:/--?|-=|\+\+?|\+=|!=?|~|\*\*?|\*=|\/=?|%=?|<<=?|>>=?|<=?|>=?|==?|&&?|&=|\^=?|\|\|?|\|=|\?|:/,punctuation:/\(\(?|\)\)?|,|;/}},{pattern:/\$\([^)]+\)|`[^`]+`/,greedy:!0,inside:{variable:/^\$\(|^`|\)$|`$/}},/\$(?:[\w#?*!@]+|\{[^}]+\})/i]};e.languages.bash={shebang:{pattern:/^#!\s*\/bin\/bash|^#!\s*\/bin\/sh/,alias:"important"},comment:{pattern:/(^|[^"{\\])#.*/,lookbehind:!0},string:[{pattern:/((?:^|[^<])<<\s*)["']?(\w+?)["']?\s*\r?\n(?:[\s\S])*?\r?\n\2/,lookbehind:!0,greedy:!0,inside:n},{pattern:/(["'])(?:\\[\s\S]|\$\([^)]+\)|`[^`]+`|(?!\1)[^\\])*\1/,greedy:!0,inside:n}],variable:n.variable,function:{pattern:/(^|[\s;|&])(?:alias|apropos|apt-get|aptitude|aspell|awk|basename|bash|bc|bg|builtin|bzip2|cal|cat|cd|cfdisk|chgrp|chmod|chown|chroot|chkconfig|cksum|clear|cmp|comm|command|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|du|egrep|eject|enable|env|ethtool|eval|exec|expand|expect|export|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|getopts|git|grep|groupadd|groupdel|groupmod|groups|gzip|hash|head|help|hg|history|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|jobs|join|kill|killall|less|link|ln|locate|logname|logout|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|make|man|mkdir|mkfifo|mkisofs|mknod|more|most|mount|mtools|mtr|mv|mmv|nano|netstat|nice|nl|nohup|notify-send|npm|nslookup|open|op|passwd|paste|pathchk|ping|pkill|popd|pr|printcap|printenv|printf|ps|pushd|pv|pwd|quota|quotacheck|quotactl|ram|rar|rcp|read|readarray|readonly|reboot|rename|renice|remsync|rev|rm|rmdir|rsync|screen|scp|sdiff|sed|seq|service|sftp|shift|shopt|shutdown|sleep|slocate|sort|source|split|ssh|stat|strace|su|sudo|sum|suspend|sync|tail|tar|tee|test|time|timeout|times|touch|top|traceroute|trap|tr|tsort|tty|type|ulimit|umask|umount|unalias|uname|unexpand|uniq|units|unrar|unshar|uptime|useradd|userdel|usermod|users|uuencode|uudecode|v|vdir|vi|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yes|zip)(?=$|[\s;|&])/,lookbehind:!0},keyword:{pattern:/(^|[\s;|&])(?:let|:|\.|if|then|else|elif|fi|for|break|continue|while|in|case|function|select|do|done|until|echo|exit|return|set|declare)(?=$|[\s;|&])/,lookbehind:!0},boolean:{pattern:/(^|[\s;|&])(?:true|false)(?=$|[\s;|&])/,lookbehind:!0},operator:/&&?|\|\|?|==?|!=?|<<<?|>>|<=?|>=?|=~/,punctuation:/\$?\(\(?|\)\)?|\.\.|[{}[\];]/};var t=n.variable[1].inside;t.string=e.languages.bash.string,t.function=e.languages.bash.function,t.keyword=e.languages.bash.keyword,t.boolean=e.languages.bash.boolean,t.operator=e.languages.bash.operator,t.punctuation=e.languages.bash.punctuation,e.languages.shell=e.languages.bash}(Prism)},function(e,n){Prism.languages.css={comment:/\/\*[\s\S]*?\*\//,atrule:{pattern:/@[\w-]+?.*?(?:;|(?=\s*\{))/i,inside:{rule:/@[\w-]+/}},url:/url\((?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,selector:/[^{}\s][^{};]*?(?=\s*\{)/,string:{pattern:/("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},property:/[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,important:/\B!important\b/i,function:/[-a-z0-9]+(?=\()/i,punctuation:/[(){};:]/},Prism.languages.css.atrule.inside.rest=Prism.languages.css,Prism.languages.markup&&(Prism.languages.insertBefore("markup","tag",{style:{pattern:/(<style[\s\S]*?>)[\s\S]*?(?=<\/style>)/i,lookbehind:!0,inside:Prism.languages.css,alias:"language-css",greedy:!0}}),Prism.languages.insertBefore("inside","attr-value",{"style-attr":{pattern:/\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i,inside:{"attr-name":{pattern:/^\s*style/i,inside:Prism.languages.markup.tag.inside},punctuation:/^\s*=\s*['"]|['"]\s*$/,"attr-value":{pattern:/.+/i,inside:Prism.languages.css}},alias:"language-css"}},Prism.languages.markup.tag))},function(e,n){Prism.languages.json={property:/"(?:\\.|[^\\"\r\n])*"(?=\s*:)/i,string:{pattern:/"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,greedy:!0},number:/\b0x[\dA-Fa-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee][+-]?\d+)?/,punctuation:/[{}[\]);,]/,operator:/:/g,boolean:/\b(?:true|false)\b/i,null:/\bnull\b/i},Prism.languages.jsonp=Prism.languages.json},function(e,n){!function(e){var n=e.util.clone(e.languages.javascript);e.languages.jsx=e.languages.extend("markup",n),e.languages.jsx.tag.pattern=/<\/?(?:[\w.:-]+\s*(?:\s+(?:[\w.:-]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s{'">=]+|\{(?:\{(?:\{[^}]*\}|[^{}])*\}|[^{}])+\}))?|\{\.{3}[a-z_$][\w$]*(?:\.[a-z_$][\w$]*)*\}))*\s*\/?)?>/i,e.languages.jsx.tag.inside.tag.pattern=/^<\/?[^\s>\/]*/i,e.languages.jsx.tag.inside["attr-value"].pattern=/=(?!\{)(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">]+)/i,e.languages.insertBefore("inside","attr-name",{spread:{pattern:/\{\.{3}[a-z_$][\w$]*(?:\.[a-z_$][\w$]*)*\}/,inside:{punctuation:/\.{3}|[{}.]/,"attr-value":/\w+/}}},e.languages.jsx.tag),e.languages.insertBefore("inside","attr-value",{script:{pattern:/=(\{(?:\{(?:\{[^}]*\}|[^}])*\}|[^}])+\})/i,inside:{"script-punctuation":{pattern:/^=(?={)/,alias:"punctuation"},rest:e.languages.jsx},alias:"language-javascript"}},e.languages.jsx.tag);var t=function(e){return e?"string"==typeof e?e:"string"==typeof e.content?e.content:e.content.map(t).join(""):""},r=function(n){for(var a=[],o=0;o<n.length;o++){var i=n[o],s=!1;if("string"!=typeof i&&("tag"===i.type&&i.content[0]&&"tag"===i.content[0].type?"</"===i.content[0].content[0].content?a.length>0&&a[a.length-1].tagName===t(i.content[0].content[1])&&a.pop():"/>"===i.content[i.content.length-1].content||a.push({tagName:t(i.content[0].content[1]),openedBraces:0}):a.length>0&&"punctuation"===i.type&&"{"===i.content?a[a.length-1].openedBraces++:a.length>0&&a[a.length-1].openedBraces>0&&"punctuation"===i.type&&"}"===i.content?a[a.length-1].openedBraces--:s=!0),(s||"string"==typeof i)&&a.length>0&&0===a[a.length-1].openedBraces){var u=t(i);o<n.length-1&&("string"==typeof n[o+1]||"plain-text"===n[o+1].type)&&(u+=t(n[o+1]),n.splice(o+1,1)),o>0&&("string"==typeof n[o-1]||"plain-text"===n[o-1].type)&&(u=t(n[o-1])+u,n.splice(o-1,1),o--),n[o]=new e.Token("plain-text",u,null,u)}i.content&&"string"!=typeof i.content&&r(i.content)}};e.hooks.add("after-tokenize",function(e){("jsx"===e.language||"tsx"===e.language)&&r(e.tokens)})}(Prism)},function(e,n){Prism.languages.less=Prism.languages.extend("css",{comment:[/\/\*[\s\S]*?\*\//,{pattern:/(^|[^\\])\/\/.*/,lookbehind:!0}],atrule:{pattern:/@[\w-]+?(?:\([^{}]+\)|[^(){};])*?(?=\s*\{)/i,inside:{punctuation:/[:()]/}},selector:{pattern:/(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\([^{}]*\)|[^{};@])*?(?=\s*\{)/,inside:{variable:/@+[\w-]+/}},property:/(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/i,punctuation:/[{}();:,]/,operator:/[+\-*\/]/}),Prism.languages.insertBefore("less","punctuation",{function:Prism.languages.less.function}),Prism.languages.insertBefore("less","property",{variable:[{pattern:/@[\w-]+\s*:/,inside:{punctuation:/:/}},/@@?[\w-]+/],"mixin-usage":{pattern:/([{;]\s*)[.#](?!\d)[\w-]+.*?(?=[(;])/,lookbehind:!0,alias:"function"}})},function(e,n){!function(e){e.languages.sass=e.languages.extend("css",{comment:{pattern:/^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t]+.+)*/m,lookbehind:!0}}),e.languages.insertBefore("sass","atrule",{"atrule-line":{pattern:/^(?:[ \t]*)[@+=].+/m,inside:{atrule:/(?:@[\w-]+|[+=])/m}}}),delete e.languages.sass.atrule;var n=/\$[-\w]+|#\{\$[-\w]+\}/,t=[/[+*\/%]|[=!]=|<=?|>=?|\b(?:and|or|not)\b/,{pattern:/(\s+)-(?=\s)/,lookbehind:!0}];e.languages.insertBefore("sass","property",{"variable-line":{pattern:/^[ \t]*\$.+/m,inside:{punctuation:/:/,variable:n,operator:t}},"property-line":{pattern:/^[ \t]*(?:[^:\s]+ *:.*|:[^:\s]+.*)/m,inside:{property:[/[^:\s]+(?=\s*:)/,{pattern:/(:)[^:\s]+/,lookbehind:!0}],punctuation:/:/,variable:n,operator:t,important:e.languages.sass.important}}}),delete e.languages.sass.property,delete e.languages.sass.important,delete e.languages.sass.selector,e.languages.insertBefore("sass","punctuation",{selector:{pattern:/([ \t]*)\S(?:,?[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,?[^,\r\n]+)*)*/,lookbehind:!0}})}(Prism)},function(e,n){Prism.languages.scss=Prism.languages.extend("css",{comment:{pattern:/(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,lookbehind:!0},atrule:{pattern:/@[\w-]+(?:\([^()]+\)|[^(])*?(?=\s+[{;])/,inside:{rule:/@[\w-]+/}},url:/(?:[-a-z]+-)*url(?=\()/i,selector:{pattern:/(?=\S)[^@;{}()]?(?:[^@;{}()]|&|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}]+[:{][^}]+))/m,inside:{parent:{pattern:/&/,alias:"important"},placeholder:/%[-\w]+/,variable:/\$[-\w]+|#\{\$[-\w]+\}/}}}),Prism.languages.insertBefore("scss","atrule",{keyword:[/@(?:if|else(?: if)?|for|each|while|import|extend|debug|warn|mixin|include|function|return|content)/i,{pattern:/( +)(?:from|through)(?= )/,lookbehind:!0}]}),Prism.languages.scss.property={pattern:/(?:[\w-]|\$[-\w]+|#\{\$[-\w]+\})+(?=\s*:)/i,inside:{variable:/\$[-\w]+|#\{\$[-\w]+\}/}},Prism.languages.insertBefore("scss","important",{variable:/\$[-\w]+|#\{\$[-\w]+\}/}),Prism.languages.insertBefore("scss","function",{placeholder:{pattern:/%[-\w]+/,alias:"selector"},statement:{pattern:/\B!(?:default|optional)\b/i,alias:"keyword"},boolean:/\b(?:true|false)\b/,null:/\bnull\b/,operator:{pattern:/(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|or|not)(?=\s)/,lookbehind:!0}}),Prism.languages.scss.atrule.inside.rest=Prism.languages.scss},function(e,n){var t=Prism.util.clone(Prism.languages.typescript);Prism.languages.tsx=Prism.languages.extend("jsx",t)},function(e,n){Prism.languages.typescript=Prism.languages.extend("javascript",{keyword:/\b(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield|module|declare|constructor|namespace|abstract|require|type)\b/,builtin:/\b(?:string|Function|any|number|boolean|Array|symbol|console)\b/}),Prism.languages.ts=Prism.languages.typescript},function(e,n){e.exports="# Installation\n\n```\nnpm install react-devdoc\n```\n\nSimply `react-markdown` and `prismjs` wrapper components;\n\n# Usage\n\n```typescript jsx\nimport React from 'react';\nimport { Markdown, CodeBlock } from 'react-devdocs';\n\n// ⭐️ load prismjs theme\nimport 'prismjs/themes/prism-okaidia.css';\n\nimport { SampleComponent } from './sample';\n\nexport function Component() {\n  return (\n    <div>\n      {/* ⭐️ Set webpack *.md file loader to raw-loader */}\n      <Markdown text={require('!!raw-loader!./sample.md')}/>\n      <SampleComponent/>\n      {/* ⭐️ Get source code use raw-loader */}\n      <CodeBlock value={require('!!raw-loader!./sample')} language=\"tsx\"/>\n    </div> \n  );\n}\n```\n\n"},function(e,n,t){"use strict";t.r(n);var r=t(0),a=t.n(r),o=t(1);n.default=function(){return a.a.createElement("div",null,a.a.createElement(o.b,{text:t(49)}))}},function(e,n){e.exports="Installation\n===============================\n\n```\nnpm install react-router-store\n```\n\n`react-router-store` makes the `react-router` processing simpler for server side rendering.\n\nUsage\n===============================\n\nCreate async and sync route stores\n----------------------------------------\n\n```typescript\n// asyncRouteStore.ts\nimport { RouteStore, AsyncRouteStore } from 'react-router-store';\n\nexport const asyncRouteStore: RouteStore = new AsyncRouteStore([\n  {\n    path: '/',\n    exact: true,\n    component: () => import('./pages/main'),\n  },\n  {\n    path: '/sample',\n    component: () => import('./pages/sample'),\n  },\n]);\n```\n\n```typescript\n// syncRouteStore.ts\nimport { RouteStore, SyncRouteStore } from 'react-router-store';\n\nimport main from './pages/main';\nimport sample from './pages/sample'; \n\nexport const syncRouteStore: RouteStore = new SyncRouteStore([\n  {\n      path: '/',\n      exact: true,\n      component: main,\n    },\n    {\n      path: '/sample',\n      component: sample,\n    },\n]);\n```\n\nAdd `<Route/>`\n----------------------------------------\n\n```typescript jsx\n// main.tsx\nimport React from 'react';\nimport { RouteStore } from 'react-router-store';\nimport { BrowserRouter, Route, Link } from 'react-router-dom';\n\ninterface MainProps {\n  routeStore: RouteStore;\n}\n\nexport function Main({ routeStore }: MainProps) {\n  return (\n    <div id=\"layout\">\n      <ul id=\"navigation\">\n        <li>\n          <Link to=\"/\">Home</Link>\n        </li>\n        <li>\n          <Link to=\"/sample\">Home</Link>\n        </li>\n      </ul>\n      \n      <div id=\"content\">\n        {/*<Route exact path=\"/\" component={}/>*/}\n        {/*<Route path=\"/sample\" component={}/>*/}\n        {routeStore.getRoute('/')}\n        {routeStore.getRoute('/sample')}\n      </div>\n    </div>\n  )\n}\n```\n\nCreates entry files\n----------------------------------------\n\nCreates entry files for client and server.\n\n```typescript jsx\n// client.tsx\nimport React from 'react';\nimport { hydrate, render } from 'react-dom';\nimport { BrowserRouter, Route, Link } from 'react-router-dom';\n\nimport { asyncRouteStore } from './asyncRouteStore';\nimport { Main } from './main';\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Main routeStore={asyncRouteStore}/>\n    </BrowserRouter>\n  )\n}\n\nif (window.__INITIAL_STATE__) {\n  asyncRouteStore.preload(location.pathname).then(() => {\n    hydrate(<App/>, document.querySelector('#app'));\n  });\n} else {\n  render(<App/>, document.querySelector('#app'));\n}\n```\n\nFor client, preloads the route component before running the app.\n\n```typescript jsx\n// ssr.tsx\nimport React from 'react';\nimport { StaticRouter } from 'react-router';\nimport express, { Express, Request, Response } from 'express';\nimport { renderToString } from 'react-dom/server';\n\nimport { syncRouteStore } from './syncRouteStore';\nimport { Main } from './main';\n\nfunction renderHtml(url: string, initialState: object): string {\n  const htmlText: string = renderToString(\n    <StaticRouter location={url} context={{}}>\n      <Main routeStore={syncRouteStore}/>\n    </StaticRouter>\n  );\n  \n  return `\n    <html>\n      <head>\n        <meta charset=UTF-8>\n        <script>\n          window.__INITIAL_STATE__ = ${initialState.replace(/</g, '\\\\u003c')};\n        <\/script>\n      </head>\n      <body>\n        <div id=\"app\">${htmlText}</div>\n      </body>\n    </html>\n  `;\n}\n\nconst app: Express = express();\n\napp.get('/', (req: Request, res: Response) => {\n  res.send(renderHtml(req.url, {}));\n});\n\napp.get('/sample', (req: Request, res: Response) => {\n  res.send(renderHtml(req.url, {}));\n});\n\napp.listen(8080);\n```\n\nAdd a test\n----------------------------------------\n\nAdd a test to make sure both stores are set to the same options.\n\n```typescript\nimport { compareRouteOptions } from 'react-router-store';\nimport { asyncRouteStore } from './asyncRouteStore';\nimport { syncRouteStore } from './syncRouteStore';\n\ndescribe('/route', () => {\n  it('Should be matched all route options of stores', () => {\n    expect(compareRouteOptions(\n      asyncRouteStore.getRouteOptions(),\n      syncRouteStore.getRouteOptions(),\n    )).toBeTruthy();\n  });\n});\n```\n\n"},function(e,n,t){"use strict";t.r(n);var r=t(0),a=t.n(r),o=t(1);n.default=function(){return a.a.createElement("div",null,a.a.createElement(o.b,{text:t(51)}))}},function(e,n){e.exports="# Installation\n\n```\nnpm install use-locale\n```\n\n# API\n\n- `getBrowserLocale: <LanguageCode extends string>(cookieKey: string = 'locale') => LanguageCode`\n- `useLocale: <LanguageCode extends string>(currentLocale: LanguageCode) => { locale: LanguageCode, updateLocale: (locale: LanguageCode) => void }`\n\n# Basic usage\n\n```typescript jsx\nimport React from 'react';\nimport { useLocale, getBrowserLocale } from 'use-locale';\n\ntype LanguageCode = 'en-US' | 'ko-KR';\nconst languageCodes: LanguageCode[] = ['en-US', 'ko-KR'];\n\nexport function Component() {\n  const {locale, updateLocale} = useLocale<LanguageCode>(getBrowserLocale<LanguageCode>());\n  \n  return (\n    <div>\n      <div>\n        {locale}\n      </div>\n      \n      <ul>\n        {\n          languageCodes.map(languageCode => (\n            <li key={languageCode} onClick={() => updateLocale(languageCode)}>\n              {languageCode}\n            </li>\n          ))\n        }\n      </ul>\n    </div>\n  );\n}\n```\n\nBasic use of `useLocale()` is simple.\n\n# Wrapping with React 16.3 Context\n\nHowever, the locale information should be used globally in the application, it is wrapped using the React 16.3 Context API.\n\n```typescript\nexport type LanguageCode = 'en-US' | 'ko-KR';\nexport const languageCodes: LanguageCode[] = ['en-US', 'ko-KR'];\n```\n\n```typescript jsx\nimport React, { Consumer, Context, ReactNode, useContext, createContext } from 'react';\nimport { useLocale } from 'use-locale';\nimport { LanguageCode, languageCodes } from './locale';\n\nexport interface SampleContextProps {\n  currentLocale: string;\n  children: ReactNode;\n}\n\nexport interface SampleContextState {\n  locale: LanguageCode;\n  updateLocale: (locale: LanguageCode) => void;\n}\n\n// @ts-ignore\nconst SampleContext: Context<SampleContextState> = createContext<SampleContextState>();\n\nexport function SampleContextProvider({ currentLocale, children }: SampleContextProps) {\n  const { locale, updateLocale } = useLocale<LanguageCode>(currentLocale);\n  \n  return (\n    <SampleContext.Provider value={{\n      locale,\n      updateLocale,\n    }}>\n      {children}\n    </SampleContext.Provider>\n  );\n}\n\nexport function useSampleContextState(): SampleContextState {\n  return useContext(SampleContext);\n}\n\nexport const SampleContextConsumer: Consumer<SampleContextState> = SampleContext.Consumer;\n```\n\nFirst, make a context\n\n```typescript jsx\nimport React from 'react';\nimport { SampleContextProvider } from './sample-context';\nimport { LanguageCode } from './locale';\nimport { getBrowserLocale } from 'use-locale';\nimport { Main } from './main';\n\nexport function App() {\n  return (\n    <SampleContextProvider currentLocale={getBrowserLocale<LanguageCode>()}>\n      <Main/>\n    </SampleContextProvider>\n  )\n}\n```\n\nAnd wrap the application main in the provider \n\n```typescript jsx\nimport React from 'react';\nimport { useSampleContextState } from './sample-context';\nimport { LanguageCode, languageCodes } from './locale';\n\nexport function Component() {\n  const { locale, updateLocale } = useSampleContextState();\n  \n  return (\n    <div>\n      <div>\n        {locale}\n      </div>\n      \n      <ul>\n        {\n          languageCodes.map(languageCode => (\n            <li key={languageCode} onClick={() => updateLocale(languageCode)}>\n              {languageCode}\n            </li>\n          ))\n        }\n      </ul>\n    </div>\n  );\n}\n```\n\nYou can access the locale information from anywhere in the application through the hook\n\n# SSR\n\nAdditionally, the locale information in SSR (Server Side Rendering) can be obtained via a cookie\n\n```typescript jsx\nimport express, { Express, Request, Response } from 'express';\nimport { LanguageCode } from './locale';\n\nconst app: Express = express();\n\napp.get('/', (req, res) => {\n  const locale: LanguageCode = req.cookies['locale'] || 'en-US';\n  \n  // res.send(ssr processed html text)\n});\n\napp.listen(8080);\n``` "},function(e,n,t){"use strict";t.r(n);var r=t(0),a=t.n(r),o=t(1);n.default=function(){return a.a.createElement("div",null,a.a.createElement(o.b,{text:t(53)}))}},function(e,n){e.exports="# Installation\n\n```\nnpm install use-react-intl\n```\n\nMakes `react-intl` to be used as a Function component hook.\n\nThis module can be used temporarily until `react-intl` supports the React 16.3 Context API.\n\nAfter that, it is better to use React 16.8 `useContext()` hook.\n\n# Usage\n\n```typescript jsx\nimport React from 'react';\nimport { IntlProvider } from 'use-react-intl';\nimport { App } from './app';\n\nexport function Main(locale: 'en' | 'ko', messages: {[messageId: string]: string}) {\n  return (\n    <IntlProvider locale={locale} messages={messages}>\n      <App/>\n    </IntlProvider>\n  )\n}\n```\n\nFirst, you need to add `<IntlProvider/>` to your app.\n\nIts usage is the same as `<IntlProvider/>` in `react-intl`.\n\n```typescript jsx\nimport React from 'react';\nimport { InjectedIntl } from 'react-intl';\nimport { useIntl } from 'use-react-intl';\n\nexport function Component() {\n  const intl: InjectedIntl = useIntl();\n  \n  return (\n    <span>\n      {intl.formatMessage({id: 'some.intl.text'})}\n    </span>\n  )\n}\n```\n\nThen, you can use a hook function `useIntl()`."},function(e,n,t){"use strict";t.r(n);var r=t(0),a=t.n(r),o=t(1);n.default=function(){return a.a.createElement("div",null,a.a.createElement(o.b,{text:t(55)}))}},function(e,n){e.exports="# Installation\n\n```\nnpm install use-timezone\n```\n\n# API\n\n```typescript\ninterface Timezone {\n  countryCode: string;\n  countryName: string;\n  zoneName: string;\n  gmtOffset: number;\n  timestamp: number;\n}\n```\n\n- `timezoneList: Timezone[]`\n- `getBrowserTimezone: (cookieKey: string = 'timezone') => string`\n- `useTimezone: (currentTimezone: string) => { timezone: Timezone, updateTimezone: (timezone: string | Timezone) => void }`\n\n# Basic usage\n\n```typescript jsx\nimport React from 'react';\nimport { Timezone, useTimezone, getBrowserTimezone, timezoneList } from 'use-timezone';\n\nexport function Component() {\n  const {timezone, updateTimezone} = useTimezone(getBrowserTimezone());\n  \n  return (\n    <div>\n      <div>\n        {JSON.stringify(timezone)}\n      </div>\n      \n      <ul>\n        {\n          timezoneList.map(optionTimezone => (\n            <li key={optionTimezone.zoneName} onClick={() => updateTimezone(optionTimezone)}>\n              {optionTimezone.zoneName}\n            </li>\n          ))\n        }\n      </ul>\n    </div>\n  );\n}\n```\n\nBasic use of `useTimezone()` is simple.\n\n# Wrapping with React 16.3 Context\n\nHowever, the timezone information should be used globally in the application, it is wrapped using the React 16.3 Context API.\n\n```typescript jsx\nimport React, { Consumer, Context, ReactNode, useContext, createContext } from 'react';\nimport { Timezone, useTimezone } from 'use-timezone';\n\nexport interface SampleContextProps {\n  currentTimezone: string;\n  children: ReactNode;\n}\n\nexport interface SampleContextState {\n  timezone: Timezone;\n  updateTimezone: (timezone: string | Timezone) => void;\n}\n\n// @ts-ignore\nconst SampleContext: Context<SampleContextState> = createContext<SampleContextState>();\n\nexport function SampleContextProvider({ currentTimezone, children }: SampleContextProps) {\n  const { timezone, updateTimezone } = useTimezone(currentTimezone);\n  \n  return (\n    <SampleContext.Provider value={{\n      timezone,\n      updateTimezone,\n    }}>\n      {children}\n    </SampleContext.Provider>\n  );\n}\n\nexport function useSampleContextState(): SampleContextState {\n  return useContext(SampleContext);\n}\n\nexport const SampleContextConsumer: Consumer<SampleContextState> = SampleContext.Consumer;\n```\n\nFirst, make a context\n\n```typescript jsx\nimport React from 'react';\nimport { SampleContextProvider } from './sample-context';\nimport { getBrowserTimezone } from 'use-timezone';\nimport { Main } from './main';\n\nexport function App() {\n  return (\n    <SampleContextProvider currentTimezone={getBrowserTimezone()}>\n      <Main/>\n    </SampleContextProvider>\n  )\n}\n```\n\nAnd wrap the application main in the provider \n\n```typescript jsx\nimport React from 'react';\nimport { useSampleContextState } from './sample-context';\nimport { Timezone, useTimezone, getBrowserTimezone, timezoneList } from 'use-timezone';\n\nexport function Component() {\n  const { timezone, updateTimezone } = useSampleContextState();\n  \n  return (\n    <div>\n      <div>\n        {JSON.stringify(timezone)}\n      </div>\n      \n      <ul>\n        {\n          timezoneList.map(optionTimezone => (\n            <li key={optionTimezone.zoneName} onClick={() => updateTimezone(optionTimezone)}>\n              {optionTimezone.zoneName}\n            </li>\n          ))\n        }\n      </ul>\n    </div>\n  );\n}\n```\n\nYou can access the timezone information from anywhere in the application through the hook\n\n# SSR\n\nAdditionally, the timezone information in SSR (Server Side Rendering) can be obtained via a cookie\n\n```typescript jsx\nimport express, { Express, Request, Response } from 'express';\n\nconst app: Express = express();\n\napp.get('/', (req, res) => {\n  const timezone: string = req.cookies['timezone'] || 'Asia/Seoul';\n  \n  // res.send(ssr processed html text)\n});\n\napp.listen(8080);\n``` "},function(e,n,t){"use strict";t.r(n);var r=t(0),a=t.n(r),o=t(1);n.default=function(){return a.a.createElement("div",null,a.a.createElement(o.b,{text:t(57)}),a.a.createElement(o.a,{value:t(58),language:"typescript"}))}},function(e,n){e.exports="# immer\n\n1. `object`, `array`의 경우 완벽하게 작동한다\n2. `Set`, `Map`은 제대로 동작하지 않는다. `new Set(originSet)`과 같이 사용하는게 더 낫다\n3. `mobx`의 경우 `@observable.ref`를 사용해서 `Observable Array`로 전환되지 않게 처리하면 문제 없다"},function(e,n){e.exports="import produce from 'immer';\nimport { action, IValueDidChange, observable, observe } from 'mobx';\n\ndescribe('immer', () => {\n  it('Test Set, Map', () => {\n    const set1: Set<string> = new Set(['a', 'b', 'c']);\n    //const set2: Set<string> = produce(set1, (draft: Set<string>) => {\n    //  draft.delete('b');\n    //  draft.add('d');\n    //});\n    const set2: Set<string> = new Set<string>(set1);\n    set2.delete('b');\n    set2.add('d');\n    \n    expect(set1 === set2).toBeFalsy();\n    expect(Array.from(set1)).toEqual(['a', 'b', 'c']);\n    expect(Array.from(set2)).toEqual(['a', 'c', 'd']);\n    \n    const map1: Map<string, number> = new Map([['a', 1], ['b', 2], ['c', 3]]);\n    //const map2: Map<string, number> = produce(map1, (draft: Map<string, number>) => {\n    //  map2.delete('b');\n    //  map2.set('d', 4);\n    //});\n    const map2: Map<string, number> = new Map<string, number>(map1);\n    map2.delete('b');\n    map2.set('d', 4);\n    \n    expect(map1 === map2).toBeFalsy();\n    expect(Array.from(map1.keys())).toEqual(['a', 'b', 'c']);\n    expect(Array.from(map1.values())).toEqual([1, 2, 3]);\n    expect(Array.from(map2.keys())).toEqual(['a', 'c', 'd']);\n    expect(Array.from(map2.values())).toEqual([1, 3, 4]);\n  });\n  \n  it('Test basic', () => {\n    const arr: string[] = ['a', 'b', 'c'];\n    expect(produce(arr, (draft: string[]) => {\n      draft.push('d', 'e'); // ['a', 'b', 'c', 'd', 'e']\n      return draft;\n    })).toEqual(['a', 'b', 'c', 'd', 'e']);\n    \n    const obj: object = {a: 1, b: 2, c: 3};\n    expect(produce(obj, (draft: object) => {\n      draft['a'] = 3; // {a: 3, b: 2, c: 3}\n      delete draft['c']; // {a: 3, b: 2}\n      draft['d'] = 100; // {a: 3, b: 2, d: 100}\n      return draft;\n    })).toEqual({a: 3, b: 2, d: 100});\n    \n    const str: string = 'a';\n    expect(produce(str, (draft: string) => {\n      return draft + 'ccc'; // 'accc'\n    })).toEqual('accc');\n  });\n  \n  it('Test mobx', () => {\n    class Data {\n      // @observable.ref 를 사용해서 observable array로 변환되지 않도록 한다\n      @observable.ref arr: string[] = ['a', 'b', 'c'];\n      \n      @action update = (append: string) => {\n        this.arr = produce(this.arr, (draft: string[]) => {\n          draft.push(append);\n        });\n      };\n    }\n    \n    const data: Data = new Data();\n    \n    expect(Array.isArray(data.arr)).toBeTruthy();\n    expect(data.arr).toEqual(['a', 'b', 'c']);\n    \n    data.update('d');\n    \n    expect(Array.isArray(data.arr)).toBeTruthy();\n    expect(data.arr).toEqual(['a', 'b', 'c', 'd']);\n    \n    return new Promise((resolve: () => void) => {\n      observe(data, 'arr', ({oldValue, newValue}: IValueDidChange<string[]>) => {\n        expect(oldValue).toEqual(['a', 'b', 'c', 'd']);\n        expect(newValue).toEqual(['a', 'b', 'c', 'd', 'e']);\n        resolve();\n      });\n      \n      setTimeout(() => {\n        data.update('e');\n      }, 200);\n    });\n  });\n  \n  it('Test deep', () => {\n    const arr: (string | string[])[] = ['a', ['b', 'c']];\n    expect(produce(arr, (draft: (string | string[])[]) => {\n      (draft[1] as string[]).splice(1, 1); // ['a', ['b']]\n      (draft[1] as string[]).push('d'); // ['a', ['b', 'd']]\n      draft.push(['e']); // ['a', ['b', 'd'], ['e']]\n      draft.push('f'); // ['a', ['b', 'd'], ['e'], 'f']\n    })).toEqual(['a', ['b', 'd'], ['e'], 'f']);\n    \n    const obj: object = {\n      a: {\n        b: 1,\n        c: {\n          d: 2,\n        },\n      },\n      e: 3,\n    };\n    \n    expect(produce(obj, (draft: object) => {\n      delete draft['a']['b']; // {a: {c: {d: 2}}, e: 3}\n      draft['a']['c']['d'] = 5; // {a: {c: {d: 5}}, e: 3}\n      draft['a']['c']['f'] = {}; // {a: {c: {d: 5, f: {}}}, e: 3}\n      draft['a']['c']['f']['g'] = 4; // {a: {c: {d: 5, f: {g: 4}}}, e: 3}\n    })).toEqual({\n      a: {\n        c: {\n          d: 5,\n          f: {\n            g: 4,\n          },\n        },\n      },\n      e: 3,\n    });\n  });\n});"},function(e,n,t){"use strict";t.r(n);var r=t(0),a=t.n(r),o=t(1);n.default=function(){return a.a.createElement("div",null,a.a.createElement(o.b,{text:t(60)}),a.a.createElement("h2",null,"Collection"),a.a.createElement(o.a,{value:t(61),language:"typescript"}),a.a.createElement("h2",null,"Collection.Indexed"),a.a.createElement(o.a,{value:t(62),language:"typescript"}),a.a.createElement("h2",null,"Collection.Keyed"),a.a.createElement(o.a,{value:t(63),language:"typescript"}),a.a.createElement("h2",null,"List"),a.a.createElement(o.a,{value:t(64),language:"typescript"}),a.a.createElement("h2",null,"Map"),a.a.createElement(o.a,{value:t(65),language:"typescript"}),a.a.createElement("h2",null,"Stack"),a.a.createElement(o.a,{value:t(66),language:"typescript"}),a.a.createElement("h2",null,"Tree"),a.a.createElement(o.a,{value:t(67),language:"typescript"}))}},function(e,n){e.exports="# immutable\n\n1. API의 구조가 예전과 다르다 (`List.merge()`가 Overwrite가 아니라 Concat처럼 동작한다거나 `List.merge(Map)`의 기준이 `V`만 뽑아내는게 아니라 `[K, V]`를 뽑아낸다거나...)\n2. API 변화가 불안정하고, 오랫동안 작업되지 않고 있고... 사용하지 않는게 좋겠다. (`immer`로 대체)"},function(e,n){e.exports="import { Collection, fromJS, isIndexed, isKeyed, List, Map, Seq, Set, Stack } from 'immutable';\n\nexport interface C {\n  c: string;\n}\n\nexport interface B {\n  b: string;\n  children: C[];\n}\n\nexport interface A {\n  a: string;\n  children: B[];\n}\n\n// Map Type은 K에 keyof만 사용하고, V는 별개로 지정하는게 좋을 것 같다.\n// as를 써야하겠지만 이 방식이 제일 간단할 것 같다.\nexport type CMap = Map<keyof C, string>;\nexport type BMap = Map<keyof B, string | List<CMap>>;\nexport type AMap = Map<keyof A, string | List<BMap>>;\n\ndescribe('Collection', () => {\n  it('Reading Values', () => {\n    const x: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    \n    expect(x.get(0)).toEqual(1);\n    expect(x.get(1)).toEqual(2);\n    expect(x.get(2)).toEqual(3);\n    expect(x.get(3)).toBeUndefined();\n    expect(x.get<number>(3, 8)).toEqual(8); // using not set value\n    \n    expect(x.has(0)).toBeTruthy();\n    expect(x.has(1)).toBeTruthy();\n    expect(x.has(2)).toBeTruthy();\n    expect(x.has(3)).toBeFalsy();\n    \n    // Collection에 특정 V가 들어있는지 확인할 수 있다\n    expect(x.contains(1)).toBeTruthy();\n    expect(x.contains(2)).toBeTruthy();\n    expect(x.contains(3)).toBeTruthy();\n    expect(x.contains(4)).toBeFalsy();\n    \n    expect(x.includes(1)).toBeTruthy();\n    expect(x.includes(2)).toBeTruthy();\n    expect(x.includes(3)).toBeTruthy();\n    expect(x.includes(4)).toBeFalsy();\n    \n    // 처음 / 마지막 값을 가져오기\n    // arr[arr.length - 1] 를 좀 더 세련되게 대체할 수 있겠다\n    expect(x.first()).toEqual(1);\n    expect(x.last()).toEqual(3);\n  });\n  \n  it('Reading deep values', () => {\n    const x: Collection<number, AMap> = fromJS([\n      {\n        a: 'a-1',\n        children: [\n          {\n            b: 'b-11',\n            children: [\n              {c: 'c-111'},\n              {c: 'c-112'},\n            ],\n          },\n        ],\n      },\n    ]);\n    \n    // hasIn()과 getIn()이 최하위 API라는건 모든 영역에서 사용이 가능하다는 이야기...\n    expect(x.hasIn([0, 'children', 0, 'children', 0, 'c'])).toBeTruthy();\n    expect(x.getIn([0, 'children', 0, 'children', 0, 'c'])).toEqual('c-111');\n    expect(x.getIn([0, 'children', 0, 'children', 1, 'c'])).toEqual('c-112');\n  });\n  \n  it('Persistent changes', () => {\n    // Collection 단계에서는 그리 큰 의미를 가지는 API는 아닌 것 같다.\n    // update(K, (V) => V) 단계로 가야지 의미가 생길 것 같다.\n    const x: Map<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    const y: number = x.update<number>((t: Map<string, number>) => t.size);\n    const z: Map<string, number> = x.update((t: Map<string, number>) => t.filter((i: number) => i < 2));\n    \n    expect(x.size).toEqual(3);\n    expect(y).toEqual(3);\n    expect(z.size).toEqual(1);\n  });\n  \n  it('Conversion to JavaScript types', () => {\n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    expect(indexed.toArray()).toEqual([1, 2, 3]);\n    expect(indexed.toObject()).toEqual({'0': 1, '1': 2, '2': 3}); // Index가 문자로 된 Object가 만들어진다\n    expect(indexed.toJSON()).toEqual([1, 2, 3]);\n    expect(indexed.toJS()).toEqual([1, 2, 3]);\n    \n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    expect(keyed.toArray()).toEqual([['a', 1], ['b', 2], ['c', 3]]);\n    expect(keyed.toObject()).toEqual({a: 1, b: 2, c: 3});\n    expect(keyed.toJSON()).toEqual({a: 1, b: 2, c: 3});\n    expect(keyed.toJS()).toEqual({a: 1, b: 2, c: 3});\n    \n    const tree: Collection<number, AMap> = fromJS([\n      {\n        a: 'a-1',\n        children: [\n          {\n            b: 'b-11',\n            children: [\n              {c: 'c-111'},\n              {c: 'c-112'},\n            ],\n          },\n        ],\n      },\n    ]);\n    \n    const arr: AMap[] = tree.toArray() as AMap[];\n    expect(Array.isArray(arr)).toBeTruthy();\n    expect(isKeyed(arr[0])).toBeTruthy();\n    expect(isIndexed(arr[0].get('children'))).toBeTruthy();\n    expect(arr[0].getIn(['children', 0, 'children', 0, 'c'])).toEqual('c-111');\n    \n    const obj: {[k: string]: AMap} = tree.toObject();\n    expect(isKeyed(obj['0'])).toBeTruthy();\n    expect(isIndexed(obj['0'].get('children'))).toBeTruthy();\n    expect(obj['0'].getIn(['children', 0, 'children', 0, 'c'])).toEqual('c-111');\n    \n    const json: AMap[] = tree.toJSON() as AMap[];\n    expect(Array.isArray(json)).toBeTruthy();\n    expect(isKeyed(json[0])).toBeTruthy();\n    expect(isIndexed(json[0].get('children'))).toBeTruthy();\n    expect(json[0].getIn(['children', 0, 'children', 0, 'c'])).toEqual('c-111');\n    \n    const js: A[] = tree.toJS() as A[];\n    expect(Array.isArray(js)).toBeTruthy();\n    expect(js[0].a).toEqual('a-1');\n    expect(Array.isArray(js[0].children)).toBeTruthy();\n    expect(js[0].children[0].children[0].c).toEqual('c-111');\n  });\n  \n  it('Iterators', () => {\n    // ES6 IterableIterator를 return한다.\n    // 단순히 K, V 중 하나를 Filtering 하는 용도나\n    // Iterator를 받아들이는 외부 API들과의 연동에 사용할만 하겠다.\n    \n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    \n    const indexedKeysIterator: IterableIterator<number> = indexed.keys();\n    expect(indexedKeysIterator.next()).toEqual({done: false, value: 0});\n    expect(indexedKeysIterator.next()).toEqual({done: false, value: 1});\n    expect(indexedKeysIterator.next()).toEqual({done: false, value: 2});\n    expect(indexedKeysIterator.next()).toEqual({done: true, value: undefined});\n    \n    const indexedValuesIterator: IterableIterator<number> = indexed.values();\n    expect(indexedValuesIterator.next()).toEqual({done: false, value: 1});\n    expect(indexedValuesIterator.next()).toEqual({done: false, value: 2});\n    expect(indexedValuesIterator.next()).toEqual({done: false, value: 3});\n    expect(indexedValuesIterator.next()).toEqual({done: true, value: undefined});\n    \n    const indexedEntriesIterator: IterableIterator<[number, number]> = indexed.entries();\n    expect(indexedEntriesIterator.next()).toEqual({done: false, value: [0, 1]});\n    expect(indexedEntriesIterator.next()).toEqual({done: false, value: [1, 2]});\n    expect(indexedEntriesIterator.next()).toEqual({done: false, value: [2, 3]});\n    expect(indexedEntriesIterator.next()).toEqual({done: true, value: undefined});\n    \n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    \n    const keyedKeysIterator: IterableIterator<string> = keyed.keys();\n    expect(keyedKeysIterator.next()).toEqual({done: false, value: 'a'});\n    expect(keyedKeysIterator.next()).toEqual({done: false, value: 'b'});\n    expect(keyedKeysIterator.next()).toEqual({done: false, value: 'c'});\n    expect(keyedKeysIterator.next()).toEqual({done: true, value: undefined});\n    \n    const keyedValuesIterator: IterableIterator<number> = keyed.values();\n    expect(keyedValuesIterator.next()).toEqual({done: false, value: 1});\n    expect(keyedValuesIterator.next()).toEqual({done: false, value: 2});\n    expect(keyedValuesIterator.next()).toEqual({done: false, value: 3});\n    expect(keyedValuesIterator.next()).toEqual({done: true, value: undefined});\n    \n    const keyedEntriesIterator: IterableIterator<[string, number]> = keyed.entries();\n    expect(keyedEntriesIterator.next()).toEqual({done: false, value: ['a', 1]});\n    expect(keyedEntriesIterator.next()).toEqual({done: false, value: ['b', 2]});\n    expect(keyedEntriesIterator.next()).toEqual({done: false, value: ['c', 3]});\n    expect(keyedEntriesIterator.next()).toEqual({done: true, value: undefined});\n  });\n  \n  it('Collections (Seq)', () => {\n    // Iterator와 유사하지만 Seq를 내보내준다.\n    // Immutable 특성이 필요하다면 쓸만 하겠다.\n    \n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    \n    const indexedKeySeq: Seq.Indexed<number> = indexed.keySeq();\n    expect(indexedKeySeq.get(0)).toEqual(0);\n    expect(indexedKeySeq.get(1)).toEqual(1);\n    expect(indexedKeySeq.get(2)).toEqual(2);\n    \n    const indexedValueSeq: Seq.Indexed<number> = indexed.valueSeq();\n    expect(indexedValueSeq.get(0)).toEqual(1);\n    expect(indexedValueSeq.get(1)).toEqual(2);\n    expect(indexedValueSeq.get(2)).toEqual(3);\n    \n    const indexedEntrySeq: Seq.Indexed<[number, number]> = indexed.entrySeq();\n    expect(indexedEntrySeq.get(0)).toEqual([0, 1]);\n    expect(indexedEntrySeq.get(1)).toEqual([1, 2]);\n    expect(indexedEntrySeq.get(2)).toEqual([2, 3]);\n    \n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    \n    const keyedKeySeq: Seq.Indexed<string> = keyed.keySeq();\n    expect(keyedKeySeq.get(0)).toEqual('a');\n    expect(keyedKeySeq.get(1)).toEqual('b');\n    expect(keyedKeySeq.get(2)).toEqual('c');\n    \n    const keyedValueSeq: Seq.Indexed<number> = keyed.valueSeq();\n    expect(keyedValueSeq.get(0)).toEqual(1);\n    expect(keyedValueSeq.get(1)).toEqual(2);\n    expect(keyedValueSeq.get(2)).toEqual(3);\n    \n    const keyedEntrySeq: Seq.Indexed<[string, number]> = keyed.entrySeq();\n    expect(keyedEntrySeq.get(0)).toEqual(['a', 1]);\n    expect(keyedEntrySeq.get(1)).toEqual(['b', 2]);\n    expect(keyedEntrySeq.get(2)).toEqual(['c', 3]);\n  });\n  \n  it('Conversion to Collections', () => {\n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    const set: Collection.Set<number> = Set<number>([1, 2, 3]);\n    \n    // {0..}\n    expect(indexed.toMap().equals(Map<number, number>([[0, 1], [1, 2], [2, 3]]))).toBeTruthy();\n    expect(indexed.toSet().equals(Set<number>([1, 2, 3]))).toBeTruthy();\n    expect(indexed.toStack().equals(Stack<number>([1, 2, 3]))).toBeTruthy();\n    \n    expect(keyed.toList().equals(List<number>([1, 2, 3]))).toBeTruthy();\n    expect(keyed.toSet().equals(Set<number>([1, 2, 3]))).toBeTruthy();\n    expect(keyed.toStack().equals(Stack<number>([1, 2, 3]))).toBeTruthy();\n    \n    // {1..}\n    expect(set.toMap().equals(Map<number, number>([[1, 1], [2, 2], [3, 3]]))).toBeTruthy();\n    expect(set.toList().equals(List<number>([1, 2, 3]))).toBeTruthy();\n    expect(set.toStack().equals(Stack<number>([1, 2, 3]))).toBeTruthy();\n  });\n  \n  it('Conversion to Seq', () => {\n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    const set: Collection.Set<number> = Set<number>([1, 2, 3]);\n    \n    // {0..}\n    // 같지만 equals는 false로 나온다\n    //console.log('Collection.test.ts..()', indexed.toKeyedSeq(), Seq.Keyed<number, number>([[0, 1], [1, 2], [2, 3]]));\n    //expect(indexed.toKeyedSeq().equals(Seq.Keyed<number, number>([[0, 1], [1, 2], [2, 3]]))).toBeTruthy();\n    expect(indexed.toSetSeq().equals(Seq.Set<number>([1, 2, 3]))).toBeTruthy();\n    \n    expect(keyed.toIndexedSeq().equals(Seq.Indexed<number>([1, 2, 3]))).toBeTruthy();\n    expect(keyed.toSetSeq().equals(Seq.Set<number>([1, 2, 3]))).toBeTruthy();\n    \n    // {1..}\n    // 같지만 equals는 false로 나온다\n    //console.log('Collection.test.ts..()', set.toKeyedSeq(), Seq.Keyed<number, number>([[1, 1], [2, 2], [3, 3]]));\n    //expect(set.toKeyedSeq().equals(Seq.Keyed<number, number>([[1, 1], [2, 2], [3, 3]]))).toBeTruthy();\n    expect(set.toIndexedSeq().equals(Seq.Indexed<number>([1, 2, 3]))).toBeTruthy();\n  });\n  \n  it('Sequence algorithms', () => {\n    // map, filter, sort 모두 잘 작동된다.\n    // 사용에 주저할 필요가 없다. 심리적인 장벽을 허물자.\n    \n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    \n    expect(\n      indexed\n        .map<string>((v: number) => 'a' + v)\n        .equals(List<string>(['a1', 'a2', 'a3'])),\n    ).toBeTruthy();\n    \n    expect(\n      indexed\n        .filter((v: number) => v > 2)\n        .equals(List<number>([3])),\n    ).toBeTruthy();\n    \n    expect(\n      indexed\n        .filterNot((v: number) => v > 2)\n        .equals(List<number>([1, 2])),\n    ).toBeTruthy();\n    \n    expect(indexed.reverse().equals(List<number>([3, 2, 1]))).toBeTruthy();\n    \n    expect(\n      indexed\n        .sort((a: number, b: number) => a > b ? -1 : 1)\n        .equals(List<number>([3, 2, 1])),\n    ).toBeTruthy();\n    \n    // Value Mapper를 사용해서 비교가 될 숫자를 도출할 수 있다.\n    // 손에 익히면 도움이 많이 될 것 같다\n    expect(\n      List<{a: number}>([{a: 1}, {a: 2}, {a: 3}])\n        .sortBy<number>(\n          (v: {a: number}) => v.a,\n          (a: number, b: number) => a > b ? -1 : 1,\n        )\n        .toArray(),\n    ).toEqual([{a: 3}, {a: 2}, {a: 1}]);\n    \n    // 특정 V를 바탕으로 Group을 만드는 작업. 의외로 도움이 많이 될 것 같다.\n    expect(\n      List<{c: string, a: number}>([\n        {c: 'red', a: 1},\n        {c: 'red', a: 2},\n        {c: 'blue', a: 3},\n        {c: 'red', a: 4},\n        {c: 'blue', a: 5},\n      ])\n        .groupBy<string>((v: {c: string, a: number}) => v.c)\n        .toJS(),\n    ).toEqual({\n      red: [\n        {c: 'red', a: 1},\n        {c: 'red', a: 2},\n        {c: 'red', a: 4},\n      ],\n      blue: [\n        {c: 'blue', a: 3},\n        {c: 'blue', a: 5},\n      ],\n    });\n    \n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    \n    expect(\n      keyed\n        .map<string>((v: number, k: string) => k + v)\n        .equals(Map<string>({a: 'a1', b: 'b2', c: 'c3'})),\n    ).toBeTruthy();\n    \n    expect(\n      keyed\n        .filter((v: number, k: string) => v > 1)\n        .equals(Map<number>({b: 2, c: 3})),\n    ).toBeTruthy();\n    \n    expect(\n      keyed\n        .filterNot((v: number, k: string) => v > 1)\n        .equals(Map<number>({a: 1})),\n    ).toBeTruthy();\n    \n    expect(\n      keyed\n        .reverse()\n        .equals(keyed),\n    ).toBeTruthy();\n    // Collection.Keyed 역시 reverse(), sort(), sortBy() 가 작동하지만 특별한 의미가 없다\n    \n    // Indexed와는 다르게 하위 리스트가 Keyed가 된다\n    expect(\n      Map<{c: string, v: number}>({\n        a: {c: 'red', v: 1},\n        b: {c: 'blue', v: 2},\n        c: {c: 'red', v: 3},\n        d: {c: 'blue', v: 4},\n        e: {c: 'red', v: 5},\n      })\n        .groupBy<string>((v: {c: string, v: number}) => v.c)\n        .toJS(),\n    ).toEqual({\n      red: {\n        a: {c: 'red', v: 1},\n        c: {c: 'red', v: 3},\n        e: {c: 'red', v: 5},\n      },\n      blue: {\n        b: {c: 'blue', v: 2},\n        d: {c: 'blue', v: 4},\n      },\n    });\n  });\n  \n  it('Side Effect', () => {\n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    const set: Collection.Set<number> = Set<number>([1, 2, 3]);\n    \n    indexed.forEach((v: number, k: number, iter: Collection<number, number>) => {\n      expect(typeof v).toEqual('number');\n      expect(typeof k).toEqual('number');\n      expect(iter).toEqual(indexed);\n    });\n    \n    keyed.forEach((v: number, k: string, iter: Collection.Keyed<string, number>) => {\n      expect(typeof v).toEqual('number');\n      expect(typeof k).toEqual('string');\n      expect(iter).toEqual(keyed);\n    });\n    \n    set.forEach((v: number, k: number, iter: Collection.Set<number>) => {\n      expect(typeof v).toEqual('number');\n      expect(typeof k).toEqual('number');\n      expect(iter).toEqual(set);\n    });\n  });\n  \n  it('Creating Subsets', () => {\n    // 순서를 기준으로 하기 때문에 Keyed나 Set은 의미가 없을 것 같다.\n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    \n    // 잘라내기\n    expect(indexed.slice(2).equals(List<number>([3]))).toBeTruthy();\n    // 처음을 제외\n    expect(indexed.rest().equals(List<number>([2, 3]))).toBeTruthy();\n    // 마지막을 제외\n    expect(indexed.butLast().equals(List<number>([1, 2]))).toBeTruthy();\n    \n    // 앞의 몇 개를 제외한 나머지\n    expect(indexed.skip(2).equals(List([3]))).toBeTruthy();\n    // 뒤의 몇 개를 제외한 나머지\n    expect(indexed.skipLast(2).equals(List([1]))).toBeTruthy();\n    // false 조건이 나온 이후의 것들\n    expect(\n      indexed\n        .skipWhile((v: number) => v < 2)\n        .equals(List<number>([2, 3])),\n    ).toBeTruthy();\n    // true 조건이 나온 이후의 것들\n    expect(\n      indexed\n        .skipUntil((v: number) => v > 2)\n        .equals(List<number>([3])),\n    ).toBeTruthy();\n    \n    // skip* 보다는 take*가 좀 더 자연스러운 논리를 가진다.\n    // 건너뛰기 논리를 가진 skip* 보다는 take를 우선 사용할 일이 더 많을 것 같다.\n    \n    // 앞의 몇 개\n    expect(indexed.take(2).equals(List<number>([1, 2]))).toBeTruthy();\n    // 뒤의 몇 개\n    expect(indexed.takeLast(2).equals(List<number>([2, 3]))).toBeTruthy();\n    // false 조건이 나올때까지 가져온다\n    expect(\n      indexed\n        .takeWhile((v: number) => v < 3)\n        .equals(List<number>([1, 2])),\n    ).toBeTruthy();\n    // true 조건이 나올때까지 가져온다\n    expect(\n      indexed\n        .takeUntil((v: number) => v > 1)\n        .equals(List<number>([1])),\n    ).toBeTruthy();\n  });\n  \n  it('Combination', () => {\n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    \n    // 다른 List를 concat 할 수 있고\n    expect(\n      indexed\n        .concat(List<number>([4, 5]), List<number>([6, 7]))\n        .equals(List<number>([1, 2, 3, 4, 5, 6, 7])),\n    ).toBeTruthy();\n    \n    // Array도 가능\n    expect(\n      indexed\n        .concat([4, 5], [6, 7])\n        .equals(List<number>([1, 2, 3, 4, 5, 6, 7])),\n    ).toBeTruthy();\n    \n    // Push처럼 넣을 수도 있고\n    expect(\n      indexed\n        .concat(4, 5, 6, 7)\n        .equals(List<number>([1, 2, 3, 4, 5, 6, 7])),\n    ).toBeTruthy();\n    \n    // Collection.Keyed를 넣을 경우 V값들만 사용해서 합친다\n    expect(\n      indexed\n        .concat(Map<number>({a: 4, b: 5}).values())\n        .equals(List<number>([1, 2, 3, 4, 5])),\n    ).toBeTruthy();\n    \n    // Collection.Keyed에는 [K, V] 형태의 값들만 concat 할 수 있다\n    expect(\n      keyed\n        .concat(Map<number>({d: 4, e: 5}), Map<number>({f: 6}))\n        .equals(Map<number>({a: 1, b: 2, c: 3, d: 4, e: 5, f: 6})),\n    ).toBeTruthy();\n    \n    // object도 가능\n    expect(\n      keyed\n        .concat({d: 4, e: 5}, {f: 6})\n        .equals(Map<number>({a: 1, b: 2, c: 3, d: 4, e: 5, f: 6})),\n    ).toBeTruthy();\n    \n    // 계층형 List를 평판화 시킨다\n    expect(\n      (fromJS([[1, 2, 3], [4, 5, 6], [7, 8]]) as List<List<number>>) // of List<List<number>>\n        .flatten()\n        .equals(List<number>([1, 2, 3, 4, 5, 6, 7, 8])),\n    ).toBeTruthy();\n    \n    // Depth가 깊은 Tree들도 합친다\n    type ListTreeValue = (number | ListTree);\n    \n    interface ListTree extends List<ListTreeValue> {\n    }\n    \n    expect(\n      (fromJS([[[1, 2], [3]], [[4], [5, [6]]], [7, 8]]) as ListTree) // of List<...<number>>\n        .flatten()\n        .equals(List<number>([1, 2, 3, 4, 5, 6, 7, 8])),\n    ).toBeTruthy();\n    \n    // Shallow Depth = 1\n    expect(\n      (fromJS([[[1, 2], [3]], [[4, 5], [6]], [[7, 8]]]) as ListTree) // of List<List<List<number>>>\n        .flatten(true) // shallow = depth 1\n        .toJS(),\n    ).toEqual([[1, 2], [3], [4, 5], [6], [7, 8]]);\n    \n    // Depth 지정이 가능\n    expect(\n      (fromJS([[[1, 2], [3]], [[4, 5], [6]], [[7, 8]]]) as ListTree) // of List<List<List<number>>>\n        .flatten(1)\n        .toJS(),\n    ).toEqual([[1, 2], [3], [4, 5], [6], [7, 8]]);\n    \n    expect(\n      (fromJS([[[1, 2], [3]], [[4, 5], [6]], [[7, 8]]]) as ListTree) // of List<List<List<number>>>\n        .flatten(2)\n        .toJS(),\n    ).toEqual([1, 2, 3, 4, 5, 6, 7, 8]);\n    \n    // [K, V] Tree의 경우 최종적인 Leaf만 가져와서 flatten() 시킨다\n    type MapTreeValue = (number | MapTree);\n    \n    interface MapTree extends Map<string, MapTreeValue> {\n    }\n    \n    expect(\n      (fromJS({a: {a1: 1, a2: 2}, b: {b1: 1, b2: 2}}) as MapTree)\n        .flatten()\n        .toJS(),\n    ).toEqual({a1: 1, a2: 2, b1: 1, b2: 2});\n    \n    expect(\n      (fromJS({a: {a1: {a11: 3, a12: {a121: 1}}, a2: 2}, b: {b1: 1, b2: 2}}) as MapTree)\n        .flatten()\n        .toJS(),\n    ).toEqual({a11: 3, a121: 1, a2: 2, b1: 1, b2: 2});\n    \n    // flatMap은 map().flatten(1) 과 같다. 그리 사용할 케이스가 많다고 보긴 어려울 것 같다.\n    expect(\n      (fromJS([[1, 2, 3], [4, 5, 6], [7, 8]]) as ListTree) // of List<List<number>>\n        .flatMap((v: List<number>) => {\n          return v.map((x: number) => 'a' + x);\n        })\n        .equals(List<string>(['a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8'])),\n    ).toBeTruthy();\n  });\n  \n  it('Search for value', () => {\n    // K 기준, V 기준 검색이 모두 가능하고,\n    // 돌려받을 값도 K, V, [K, V] 모두 가능\n    \n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    \n    expect(indexed.find(\n      (v: number) => v === 2,\n    )).toEqual(2);\n    \n    expect(indexed.find(\n      (v: number) => v === 6,\n      null,\n      10,\n    )).toEqual(10);\n    \n    expect(indexed.findLast(\n      (v: number) => v === 3,\n    )).toEqual(3);\n    \n    expect(indexed.findEntry(\n      (v: number) => v === 2,\n    )).toEqual([1, 2]);\n    \n    expect(indexed.findEntry(\n      (v: number) => v === 6,\n      null,\n      10,\n    )).toEqual(10); // notSetValue가 [-1, 10]이 아니라 10으로 들어온다. 문제 많음\n    \n    expect(indexed.findLastEntry(\n      (v: number) => v === 3,\n    )).toEqual([2, 3]);\n    \n    expect(indexed.findKey(\n      (v: number) => v === 2,\n    )).toEqual(1);\n    \n    expect(indexed.findKey(\n      (v: number) => v === 6,\n    )).toEqual(undefined);\n    \n    // (V) => K    V를 넣어서 K를 가져온다\n    expect(indexed.keyOf(2)).toEqual(1);\n    expect(indexed.lastKeyOf(3)).toEqual(2);\n    \n    expect(indexed.maxBy<number>(\n      (v: number) => v === 2 ? 100 : v,\n    )).toEqual(2);\n    \n    expect(\n      List<{a: number}>([{a: 1}, {a: 2}, {a: 3}])\n        .maxBy<number>((v: {a: number}) => v.a),\n    ).toEqual({a: 3});\n    \n    expect(keyed.find(\n      (v: number) => v === 2,\n    )).toEqual(2);\n    \n    expect(keyed.keyOf(2)).toEqual('b');\n  });\n  \n  it('Comparison', () => {\n    // 전체와 부분을 비교할 수 있다.\n    // 집합 문제를 다룰때 도움이 되겠다.\n    \n    expect(\n      List<number>([2, 3, 4])\n        .isSubset(List<number>([1, 2, 3, 4, 5, 6, 7])),\n    ).toBeTruthy();\n    \n    expect(\n      List<number>([2, 3, 4])\n        .isSubset([1, 2, 3, 4, 5, 6, 7]),\n    ).toBeTruthy();\n    \n    expect(\n      List<number>([1, 2, 3, 4, 5, 6, 7])\n        .isSuperset(List<number>([2, 3, 4])),\n    ).toBeTruthy();\n    \n    expect(\n      List<number>([1, 2, 3, 4, 5, 6, 7])\n        .isSuperset([2, 3, 4]),\n    ).toBeTruthy();\n    \n    //expect(\n    //  Map<number>({c: 3, d: 4})\n    //    .isSubset(Map<number>({a: 1, b: 2, c: 3, d: 4, e: 5})),\n    //).toBeTruthy();\n    \n    // 비교 대상이 Iterable이다 보니 Collection.Keyed와 비교할 수 없다.\n    // Collection.Keyed에서는 사용하기 애매하겠다.\n    \n    expect(\n      Map<number>({c: 3, d: 4})\n        .isSubset([1, 2, 3, 4, 5]),\n    ).toBeTruthy();\n  });\n});"},function(e,n){e.exports="import { Collection, isIndexed, isKeyed, List } from 'immutable';\n\ndescribe('Collection.Indexed', () => {\n  //it('Conversion to Seq', () => {\n  //  // ???? 뭔 ㅆㅂ 에러만 나네\n  //  const indexed: Collection.Indexed<number> = List<number>([1, 2, 3, 4]);\n  //  console.log('Collection.Indexed.test.ts..()', indexed.fromEntrySeq());\n  //});\n  \n  it('Combination', () => {\n    const indexed: Collection.Indexed<number | string> = List<number>([1, 2, 3, 4]);\n    \n    // 모든 Item들의 중간에 특정 값을 끼워넣는다\n    // String Rows 처리 등 이래저래 쓸만한 케이스가 있을듯 싶은데...\n    expect(\n      indexed\n        .interpose('/')\n        .toJS(),\n    ).toEqual([1, '/', 2, '/', 3, '/', 4]);\n    \n    // 추가된 Item들을 순차적으로 배열한다\n    // [0, 3, 6]\n    // [1, 4, 8]\n    // [2, 5, 9]\n    // 와 같은 순서가 된다.\n    // 추가적으로 최소 Item 숫자에 맞춰지기 때문에 3, 4와 9가 누락된다.\n    expect(\n      indexed\n        .interleave(\n          List<number>([7, 8, 9]) as Collection<number, number>,\n          List<number>([100, 200]) as Collection<number, number>,\n        )\n        .toJS(),\n    ).toEqual([1, 7, 100, 2, 8, 200]);\n    \n    // Array.splice()와 동일\n    expect(\n      indexed\n        .splice(2, 1)\n        .toJS(),\n    ).toEqual([1, 2, 4]);\n    \n    // Collection.Indexed.interleave()와 동일하지만\n    // 2차 배열로 값들을 묶어준다\n    // 누락룰은 동일\n    expect(\n      indexed\n        .zip(\n          List<number>([7, 8, 9]) as Collection<number, number>,\n          List<number>([100, 200]) as Collection<number, number>,\n        )\n        .toJS(),\n    ).toEqual([[1, 7, 100], [2, 8, 200]]);\n    \n    // Collection.Indexed.zip()과 유사하지만\n    // 2차 배열로 묶어버리는 zip()과 다르게 어떻게 묶을지 자의적으로 선택할 수 있다.\n    // Grid와 같은 2차 배열 Data에서 합계를 낸다거나 하는데 유용할 것 같다\n    expect(\n      indexed\n        .zipWith<string>(\n          (...values: (string | number)[]) => {\n            return values.join(':');\n          },\n          List<number>([100, 200]) as Collection<number, number>,\n          List<string>(['x', 'y']) as Collection<number, string>,\n          List<string>(['!', '@']) as Collection<number, string>,\n        )\n        .toJS(),\n    ).toEqual(['1:100:x:!', '2:200:y:@']);\n    \n    expect(\n      List<number>([1, 2, 3])\n        .zipWith<number>(\n          (...values: number[]) => {\n            return values.reduce((sum: number, v: number) => sum + v, 0);\n          },\n          List<number>([10, 20, 30]) as Collection<number, number>,\n          List<number>([100, 200, 300]) as Collection<number, number>,\n          List<number>([1000, 2000, 3000]) as Collection<number, number>,\n        )\n        .toJS(),\n    ).toEqual([1111, 2222, 3333]);\n  });\n  \n  it('Search for value', () => {\n    const indexed: Collection.Indexed<number | string> = List<number>([1, 2, 3, 4]);\n    \n    // Array.indexOf()와 동일한 것들\n    expect(indexed.indexOf(2)).toEqual(1);\n    expect(indexed.lastIndexOf(3)).toEqual(2);\n    expect(indexed.findIndex((v: number | string) => v === 2)).toEqual(1);\n    expect(indexed.findLastIndex((v: number | string) => v === 3)).toEqual(2);\n  });\n});"},function(e,n){e.exports="import { Collection, Map } from 'immutable';\n\ndescribe('Collection.Keyed', () => {\n  it('Sequence functions', () => {\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3, d: 4});\n    \n    // [K, V] 를 [V, K]로 역전 시킨다. Index 생성시에 도움이 될 것 같기도 하고...\n    expect(\n      keyed\n        .flip()\n        .equals(Map<number, string>([[1, 'a'], [2, 'b'], [3, 'c'], [4, 'd']])),\n    ).toBeTruthy();\n  });\n  \n  it('Sequence algorithms', () => {\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3, d: 4});\n    \n    // K를 변조한다\n    expect(\n      keyed\n        .mapKeys((k: string) => 'x' + k)\n        .equals(Map<number>({xa: 1, xb: 2, xc: 3, xd: 4})),\n    ).toBeTruthy();\n    \n    // [K, V]를 모두 변조한다 (이게 의외로 쓸만할듯...)\n    expect(\n      keyed\n        .mapEntries((e: [string, number]) => ['x' + e[0], e[1] * 100])\n        .equals(Map<number>({xa: 100, xb: 200, xc: 300, xd: 400})),\n    ).toBeTruthy();\n  });\n});"},function(e,n){e.exports="import { List } from 'immutable';\n\ndescribe('List', () => {\n  it('Persistent changes', () => {\n    const list: List<number> = List<number>([1, 2, 3, 4]);\n    \n    expect(list.set(2, 100).toJS()).toEqual([1, 2, 100, 4]);\n    expect(list.set(4, 100).toJS()).toEqual([1, 2, 3, 4, 100]);\n    expect(list.set(5, 100).toJS()).toEqual([1, 2, 3, 4, undefined, 100]);\n    \n    expect(list.delete(0).toJS()).toEqual([2, 3, 4]);\n    expect(list.delete(2).toJS()).toEqual([1, 2, 4]);\n    expect(list.delete(5).toJS()).toEqual([1, 2, 3, 4]);\n    \n    expect(list.insert(2, 100).toJS()).toEqual([1, 2, 100, 3, 4]);\n    expect(list.insert(5, 100).toJS()).not.toEqual([1, 2, 3, 4, undefined, 100]);\n    expect(list.insert(5, 100).toJS()).toEqual([1, 2, 3, 4, 100]);\n    \n    expect(list.clear().size).toEqual(0);\n    \n    expect(list.push(5, 6).toJS()).toEqual([1, 2, 3, 4, 5, 6]);\n    expect(list.pop().toJS()).toEqual([1, 2, 3]);\n    \n    expect(list.unshift(5, 6).toJS()).toEqual([5, 6, 1, 2, 3, 4]);\n    expect(list.shift().toJS()).toEqual([2, 3, 4]);\n    \n    expect(\n      list\n        .update(2, (v: number) => v * 100)\n        .toJS(),\n    ).toEqual([1, 2, 300, 4]);\n    \n    expect(\n      list\n        .update(5, 9, (v: number) => v * 100)\n        .toJS(),\n    ).toEqual([1, 2, 3, 4, undefined, 900]);\n    \n    // concat()이 아니다. 같은 Index를 덮어쓰는 Merge다.\n    // ??? concat()이 되어버렸는데??? ㅆㅂ 이게 뭐야?\n    expect(\n      list\n        .merge(\n          List<number>([5, 6, 7]),\n          List<number>([100, 200]),\n        )\n        .toJS(),\n    ).toEqual([1, 2, 3, 4, 5, 6, 7, 100, 200]);\n    \n    //expect(\n    //  list\n    //    .mergeWith(\n    //      (oldVal, newVal) => {\n    //        return Math.max(oldVal, newVal);\n    //      },\n    //      List<number>([-1, -2, -3, -4, -5]),\n    //      List<number>([100, 200]),\n    //    )\n    //    .toJS(),\n    //).toEqual([100, 200, 3, 4, NaN]);\n  });\n  \n  //it('Deep persistent changes', () => {\n  //\n  //});\n});"},function(e,n){e.exports="import { fromJS, Map } from 'immutable';\nimport { AMap } from './Collection.test';\n\ndescribe('Map', () => {\n  it('Persistent changes', () => {\n    const map: Map<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    \n    expect(map.clear().size).toEqual(0);\n    expect(map.update('b', (b: number) => b * 100).get('b')).toEqual(200);\n    expect(map.update('z', 8, (z: number) => z * 100).get('z')).toEqual(800);\n    \n    expect(\n      map\n        .merge(Map<number>({d: 4, e: 5}))\n        .toJS(),\n    ).toEqual({a: 1, b: 2, c: 3, d: 4, e: 5});\n    \n    expect(\n      map\n        .merge({d: 4, e: 5})\n        .toJS(),\n    ).toEqual({a: 1, b: 2, c: 3, d: 4, e: 5});\n    \n    // Object.assign과 같다. 뒤에 오는 c가 최종 결과에 반영된다\n    expect(\n      map\n        .merge({c: 100, d: 4, e: 5})\n        .toJS(),\n    ).toEqual({a: 1, b: 2, c: 100, d: 4, e: 5});\n    \n    expect(\n      map\n        .mergeWith(\n          ((oldVal: number, newVal: number, k: string) => {\n            return oldVal > newVal ? oldVal : newVal; // 2. 중복을 어떻게 처리할지 결정한다\n          }),\n          {c: 100, d: 4, e: 5}, // 1. 입력된 값들 중 중복값이 있으면\n          {c: 300},\n          {c: 1000}, // 3. 중복된 값이 여러번이면 여러번 실행된다\n        )\n        .toJS(),\n    ).toEqual({a: 1, b: 2, c: 1000, d: 4, e: 5});\n  });\n  \n  it('Transient changes', () => {\n    const map: Map<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    const tree: AMap = fromJS({\n      a: 'a-1',\n      children: [\n        {\n          b: 'b-11',\n          children: [\n            {c: 'c-111'},\n            {c: 'c-112'},\n          ],\n        },\n      ],\n    });\n    \n    // Mutable... 대입해서 새로운 instance을 저장하지 않아도 된다.\n    // Bulk update를 칠때 도움이 될 것 같다.\n    expect(\n      map\n        .withMutations((mutable: Map<string, number>) => {\n          mutable.set('a', 100);\n          mutable.set('c', 300);\n          return mutable;\n        })\n        .toJS(),\n    ).toEqual({\n      a: 100,\n      b: 2,\n      c: 300,\n    });\n    \n    // Tree 때문에 고민하지 말고 그냥 setIn()을 사용하면 되겠다\n    expect(\n      tree\n        .withMutations((mutable: AMap) => {\n          mutable.set('a', 'a-2');\n          mutable.setIn(['children', 0, 'children', 1, 'c'], 'c-xxx');\n          return mutable;\n        })\n        .toJS(),\n    ).toEqual({\n      a: 'a-2',\n      children: [\n        {\n          b: 'b-11',\n          children: [\n            {c: 'c-111'},\n            {c: 'c-xxx'},\n          ],\n        },\n      ],\n    });\n  });\n});"},function(e,n){e.exports="import { List, Stack } from 'immutable';\n\n// 후입선출 (LIFO) 구조 - 마지막에 들어간게 제일 먼저 나온다\ndescribe('Stack', () => {\n  it('Reading values', () => {\n    const stack: Stack<number> = Stack<number>([1, 2, 3, 4]);\n    \n    // Collection.first()와 동일\n    expect(stack.peek()).toEqual(1);\n  });\n  \n  it('Persistent changes', () => {\n    const stack: Stack<number> = Stack<number>([1, 2, 3, 4]);\n    \n    expect(stack.clear().size).toEqual(0);\n    \n    // Stack 구조이기 때문에 push, pushAll, pop은 없는 개념이다\n    // 앞대가리로 집어넣고, peek()으로 꺼내거나 shift()로 제거한다\n    expect(stack.unshift(5, 6).toJS()).toEqual([5, 6, 1, 2, 3, 4]);\n    expect(stack.push(5, 6).toJS()).toEqual([5, 6, 1, 2, 3, 4]);\n    \n    expect(stack.unshiftAll(List<number>([5, 6])).toJS()).toEqual([5, 6, 1, 2, 3, 4]);\n    expect(stack.pushAll(List<number>([5, 6])).toJS()).toEqual([5, 6, 1, 2, 3, 4]);\n    \n    expect(stack.shift().toJS()).toEqual([2, 3, 4]);\n    expect(stack.pop().toJS()).toEqual([2, 3, 4]);\n  });\n});"},function(e,n){e.exports="import { fromJS, Map } from 'immutable';\nimport { AMap } from './Collection.test';\n\ndescribe('Tree', () => {\n  it('Persistent changes', () => {\n    // 복잡한 Tree를 merge 할 수 있다.\n    // 깊은 수준까지 적용이 된다는게 편할 것 같다.\n    expect(\n      (fromJS({\n        a: 1,\n        b: {\n          b1: 10,\n        },\n      }) as Map<string, number | object>)\n        .mergeDeep(fromJS({\n          a: {\n            a1: 1,\n          },\n          b: {\n            b2: 100,\n            b3: {\n              b31: 1,\n            },\n          },\n          c: 10,\n        }))\n        .toJS(),\n    ).toEqual({\n      a: {\n        a1: 1,\n      },\n      b: {\n        b1: 10,\n        b2: 100,\n        b3: {\n          b31: 1,\n        },\n      },\n      c: 10,\n    });\n    \n    // 깊은 수준의 비교를 지원해준다\n    // K가 Array로 왔으면 더 좋았을 것 같은데... 아쉽네...\n    // 복잡한 구조체의 Combine이 필요한 경우 (ex. Tree의 일부 값이 변경되는 경우?) 유용할 것 같다.\n    // 1. {} 와 {} 의 경우에는 자동으로 합친다\n    // 2. V 와 V 가 충돌하는 경우 알린다\n    // 3. V 와 {} 가 충돌하는 경우 알린다\n    expect(\n      (fromJS({\n        a: {\n          a1: 10,\n          a2: 3,\n        },\n        b: {\n          b1: 10,\n          b3: {\n            b31: 100,\n          },\n        },\n      }) as Map<string, number | object>)\n        .mergeDeepWith(\n          (oldVal: number | object, newVal: number | object, k: string) => {\n            // a1 10 1\n            // a2 3 Map { \"a21\": 3 }\n            // b31 100 1\n            return typeof oldVal === 'number' && typeof newVal === 'number'\n              ? oldVal > newVal\n                ? oldVal\n                : newVal\n              : newVal;\n          },\n          fromJS({\n            a: {\n              a1: 1,\n              a2: {\n                a21: 3,\n              },\n            },\n            b: {\n              b2: 100,\n              b3: {\n                b31: 1,\n              },\n            },\n            c: 10,\n          }))\n        .toJS(),\n    ).toEqual({\n      a: {\n        a1: 10,\n        a2: {\n          a21: 3,\n        },\n      },\n      b: {\n        b1: 10,\n        b2: 100,\n        b3: {\n          b31: 100,\n        },\n      },\n      c: 10,\n    });\n  });\n  \n  it('Deep persistent changes', () => {\n    const tree: AMap = fromJS({\n      a: 'a-1',\n      children: [\n        {\n          b: 'b-11',\n          children: [\n            {c: 'c-111'},\n            {c: 'c-112'},\n          ],\n        },\n      ],\n    });\n    \n    expect(\n      tree\n        .setIn(['children', 0, 'children', 0, 'd'], 100)\n        .getIn(['children', 0, 'children', 0, 'd']),\n    ).toEqual(100);\n    \n    expect(\n      tree\n        .setIn(['children', 0, 'children', 0, 'c'], 'c-xxx')\n        .getIn(['children', 0, 'children', 0, 'c']),\n    ).toEqual('c-xxx');\n    \n    expect(\n      tree\n        .deleteIn(['children', 0, 'children', 0, 'c'])\n        .getIn(['children', 0, 'children', 0, 'c']),\n    ).toBeUndefined();\n    \n    // Indexed를 지우면 밀려서 올라온다\n    expect(\n      tree\n        .deleteIn(['children', 0, 'children', 0])\n        .getIn(['children', 0, 'children', 0, 'c']),\n    ).toEqual('c-112');\n    \n    expect(\n      tree\n        .updateIn(['children', 0, 'children', 0, 'c'], (c: string) => c + '!!!')\n        .getIn(['children', 0, 'children', 0, 'c']),\n    ).toEqual('c-111!!!');\n    \n    // 특정 Key Path를 기준으로 Merge를 작동시킨다\n    // 일정 영역의 데이터를 Update 할 때 도움이 될 것 같다.\n    // Deep이 아니기 때문에 특정 Key Path의 1단계만 Merge 된다\n    expect(\n      (fromJS({\n        a: {\n          a1: 1,\n        },\n        b: {\n          b2: 100,\n          b3: {\n            b31: 1,\n            b32: 5,\n            b33: {\n              b332: 10,\n              b333: 4,\n            },\n          },\n        },\n        c: 10,\n      }) as Map<string, number | object>)\n        .mergeIn(\n          ['b', 'b3'],\n          fromJS({\n            b31: 100,\n            b33: {\n              b334: 100,\n            },\n          }),\n        )\n        .toJS(),\n    ).toEqual({\n      a: {\n        a1: 1,\n      },\n      b: {\n        b2: 100,\n        b3: {\n          b31: 100,\n          b32: 5,\n          b33: {\n            b334: 100,\n          },\n        },\n      },\n      c: 10,\n    });\n    \n    // Deep이 적용된다\n    expect(\n      (fromJS({\n        a: {\n          a1: 1,\n        },\n        b: {\n          b2: 100,\n          b3: {\n            b31: 1,\n            b32: 5,\n            b33: {\n              b332: 10,\n              b333: 4,\n            },\n          },\n        },\n        c: 10,\n      }) as Map<string, number | object>)\n        .mergeDeepIn(\n          ['b', 'b3'],\n          fromJS({\n            b31: 100,\n            b33: {\n              b334: 100,\n            },\n          }),\n        )\n        .toJS(),\n    ).toEqual({\n      a: {\n        a1: 1,\n      },\n      b: {\n        b2: 100,\n        b3: {\n          b31: 100,\n          b32: 5,\n          b33: {\n            b332: 10,\n            b333: 4,\n            b334: 100,\n          },\n        },\n      },\n      c: 10,\n    });\n  });\n});"},function(e,n,t){"use strict";t.r(n);var r=t(0),a=t.n(r),o=t(1);n.default=function(){return a.a.createElement("div",null,a.a.createElement(o.b,{text:t(69)}),a.a.createElement(o.a,{value:t(70),language:"typescript"}))}},function(e,n){e.exports="# numeral"},function(e,n){e.exports="import numeral from 'numeral';\n\ndescribe('numeral', () => {\n  it('Number formatting', () => {\n    // ---------------------------------------------\n    // 정수, 소숫점 지정\n    // ---------------------------------------------\n    expect(numeral(1000.23423).format('0,0')).toEqual('1,000');\n    expect(numeral(1000.23423).format('0,0.0000')).toEqual('1,000.2342');\n    expect(numeral(1000).format('0,0.0000')).toEqual('1,000.0000');\n    // 소수가 없으면 출력 안함\n    expect(numeral(1000).format('0,0.[0000]')).toEqual('1,000');\n    // 소수가 지정보다 많으면 잘라냄\n    expect(numeral(1000.23423).format('0,0.[000]')).toEqual('1,000.234');\n    // 소수가 지정보다 적으면 그대로 출력\n    expect(numeral(1000.2).format('0,0.[000]')).toEqual('1,000.2');\n    \n    // ---------------------------------------------\n    // 특수 표시\n    // ---------------------------------------------\n    // +, - 표시\n    expect(numeral(100).format('+0,0')).toEqual('+100');\n    expect(numeral(-100).format('+0,0')).toEqual('-100');\n    // surffix unit - k, m, b, t\n    expect(numeral(12).format('0a')).toEqual('12');\n    expect(numeral(1234).format('0a')).toEqual('1k');\n    expect(numeral(1234567).format('0a')).toEqual('1m');\n    expect(numeral(1234567890).format('0a')).toEqual('1b');\n    expect(numeral(1234567890000).format('0a')).toEqual('1t');\n    expect(numeral(12345678900000000).format('0a')).toEqual('12346t');\n    expect(numeral(1234).format('0.0a')).toEqual('1.2k');\n    expect(numeral(1234).format('0.00a')).toEqual('1.23k');\n    expect(numeral(1000).format('0.0a')).toEqual('1.0k');\n    expect(numeral(1000).format('0.[0]a')).toEqual('1k');\n    // surffix unit - 1st\n    expect(numeral(1).format('0o')).toEqual('1st');\n    expect(numeral(2).format('0o')).toEqual('2nd');\n    expect(numeral(10).format('0o')).toEqual('10th');\n    // bytes\n    expect(numeral(100).format('0b')).toEqual('100B');\n    expect(numeral(1024).format('0b')).toEqual('1KB');\n    expect(numeral(1024).format('0.0b')).toEqual('1.0KB');\n    // percentage\n    expect(numeral(1).format('0%')).toEqual('100%');\n    expect(numeral(0.987).format('0%')).toEqual('99%');\n    expect(numeral(0.98764).format('0.00%')).toEqual('98.76%');\n    expect(numeral(0.9).format('0.[000]%')).toEqual('90%');\n    expect(numeral(0.98282738).format('0.[000]%')).toEqual('98.283%');\n    \n    // ---------------------------------------------\n    // Custom\n    // ---------------------------------------------\n    // zero, null format\n    numeral.zeroFormat('###');\n    numeral.nullFormat('N/A');\n    expect(numeral(0).format('0')).toEqual('###');\n    expect(numeral(null).format('0')).toEqual('N/A');\n    // undefined는 0으로 취급된다?\n    expect(numeral(undefined).format('0')).toEqual('###');\n    // 전역적으로 변경해야만 한다. (왜?)\n    numeral.zeroFormat('-');\n    numeral.nullFormat('-');\n    expect(numeral(0).format('0')).toEqual('-');\n    expect(numeral(null).format('0')).toEqual('-');\n    expect(numeral(undefined).format('0')).toEqual('-');\n    \n    numeral.register('format', 'half', {\n      regexps: {\n        format: /(half)/,\n        unformat: /(half)/,\n      },\n      format: (value: number, format: string, roundingFunction: RoundingFunction) => {\n        // numberToFormat()은 문자를 무시한 format string을 보내준다\n        // @ts-ignore typings에 _ 정의되지 않았음\n        return numeral._.numberToFormat(value / 2, format, roundingFunction) + 'half';\n      },\n      unformat: (text: string) => {\n        // stringToNumber()는 문자를 무시한 number를 보내준다\n        // @ts-ignore typings에 _ 정의되지 않았음\n        return numeral._.stringToNumber(text) * 2;\n      },\n    });\n    \n    expect(numeral(100).format('0half')).toEqual('50half');\n    expect(numeral('51half').value()).toEqual(102);\n  });\n});"}]));