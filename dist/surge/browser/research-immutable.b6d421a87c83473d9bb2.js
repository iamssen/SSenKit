(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{353:function(e,n,t){"use strict";t.r(n);var r=t(1),a=t.n(r),u=t(652);n.default=function(){return a.a.createElement("div",null,a.a.createElement(u.b,{text:t(667)}),a.a.createElement("h2",null,"Collection"),a.a.createElement(u.a,{value:t(668),language:"typescript"}),a.a.createElement("h2",null,"Collection.Indexed"),a.a.createElement(u.a,{value:t(669),language:"typescript"}),a.a.createElement("h2",null,"Collection.Keyed"),a.a.createElement(u.a,{value:t(670),language:"typescript"}),a.a.createElement("h2",null,"List"),a.a.createElement(u.a,{value:t(671),language:"typescript"}),a.a.createElement("h2",null,"Map"),a.a.createElement(u.a,{value:t(672),language:"typescript"}),a.a.createElement("h2",null,"Stack"),a.a.createElement(u.a,{value:t(673),language:"typescript"}),a.a.createElement("h2",null,"Tree"),a.a.createElement(u.a,{value:t(674),language:"typescript"}))}},652:function(e,n,t){"use strict";var r=t(638),a=(t(639),t(640),t(641),t(642),t(643),t(644),t(645),t(646),t(647),t(648),t(649),t(1)),u=t.n(a);function o(){for(var e=arguments.length,n=new Array(e),t=0;t<e;t++)n[t]=arguments[t];for(var r=0,a=n;r<a.length;r++){var u=a[r];if("string"===typeof u)return u;if("object"===typeof u&&u.default&&"string"===typeof u.default)return u.default}}function l(e){var n=e.value,t=e.children,a=e.language,l=void 0===a?"none":a,c=o(t,n);if(!c)return null;["javascript jsx"].indexOf(l)&&(l="jsx"),["typescript jsx"].indexOf(l)&&(l="tsx"),["sh"].indexOf(l)&&(l="bash"),r.languages[l]||(l="none");var i=r.languages[l]?r.languages[l]:r.languages.js,s=Object(r.highlight)(c,i,l),d="language-"+l;return u.a.createElement("pre",{className:d},u.a.createElement("code",{className:d,dangerouslySetInnerHTML:{__html:s}}))}var c=t(650),i=t.n(c);function s(e){var n=o(e.text,e.children);return n?u.a.createElement(i.a,{source:n,renderers:{code:l}}):null}t.d(n,"a",function(){return l}),t.d(n,"b",function(){return s})},667:function(e,n,t){"use strict";t.r(n),n.default="# immutable\n\n1. API\uc758 \uad6c\uc870\uac00 \uc608\uc804\uacfc \ub2e4\ub974\ub2e4 (`List.merge()`\uac00 Overwrite\uac00 \uc544\ub2c8\ub77c Concat\ucc98\ub7fc \ub3d9\uc791\ud55c\ub2e4\uac70\ub098 `List.merge(Map)`\uc758 \uae30\uc900\uc774 `V`\ub9cc \ubf51\uc544\ub0b4\ub294\uac8c \uc544\ub2c8\ub77c `[K, V]`\ub97c \ubf51\uc544\ub0b8\ub2e4\uac70\ub098...)\n2. API \ubcc0\ud654\uac00 \ubd88\uc548\uc815\ud558\uace0, \uc624\ub7ab\ub3d9\uc548 \uc791\uc5c5\ub418\uc9c0 \uc54a\uace0 \uc788\uace0... \uc0ac\uc6a9\ud558\uc9c0 \uc54a\ub294\uac8c \uc88b\uaca0\ub2e4. (`immer`\ub85c \ub300\uccb4)"},668:function(e,n,t){"use strict";t.r(n),n.default="import { Collection, fromJS, isIndexed, isKeyed, List, Map, Seq, Set, Stack } from 'immutable';\n\nexport interface C {\n  c: string;\n}\n\nexport interface B {\n  b: string;\n  children: C[];\n}\n\nexport interface A {\n  a: string;\n  children: B[];\n}\n\n// Map Type\uc740 K\uc5d0 keyof\ub9cc \uc0ac\uc6a9\ud558\uace0, V\ub294 \ubcc4\uac1c\ub85c \uc9c0\uc815\ud558\ub294\uac8c \uc88b\uc744 \uac83 \uac19\ub2e4.\n// as\ub97c \uc368\uc57c\ud558\uaca0\uc9c0\ub9cc \uc774 \ubc29\uc2dd\uc774 \uc81c\uc77c \uac04\ub2e8\ud560 \uac83 \uac19\ub2e4.\nexport type CMap = Map<keyof C, string>;\nexport type BMap = Map<keyof B, string | List<CMap>>;\nexport type AMap = Map<keyof A, string | List<BMap>>;\n\ndescribe('Collection', () => {\n  it('Reading Values', () => {\n    const x: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    \n    expect(x.get(0)).toEqual(1);\n    expect(x.get(1)).toEqual(2);\n    expect(x.get(2)).toEqual(3);\n    expect(x.get(3)).toBeUndefined();\n    expect(x.get<number>(3, 8)).toEqual(8); // using not set value\n    \n    expect(x.has(0)).toBeTruthy();\n    expect(x.has(1)).toBeTruthy();\n    expect(x.has(2)).toBeTruthy();\n    expect(x.has(3)).toBeFalsy();\n    \n    // Collection\uc5d0 \ud2b9\uc815 V\uac00 \ub4e4\uc5b4\uc788\ub294\uc9c0 \ud655\uc778\ud560 \uc218 \uc788\ub2e4\n    expect(x.contains(1)).toBeTruthy();\n    expect(x.contains(2)).toBeTruthy();\n    expect(x.contains(3)).toBeTruthy();\n    expect(x.contains(4)).toBeFalsy();\n    \n    expect(x.includes(1)).toBeTruthy();\n    expect(x.includes(2)).toBeTruthy();\n    expect(x.includes(3)).toBeTruthy();\n    expect(x.includes(4)).toBeFalsy();\n    \n    // \ucc98\uc74c / \ub9c8\uc9c0\ub9c9 \uac12\uc744 \uac00\uc838\uc624\uae30\n    // arr[arr.length - 1] \ub97c \uc880 \ub354 \uc138\ub828\ub418\uac8c \ub300\uccb4\ud560 \uc218 \uc788\uaca0\ub2e4\n    expect(x.first()).toEqual(1);\n    expect(x.last()).toEqual(3);\n  });\n  \n  it('Reading deep values', () => {\n    const x: Collection<number, AMap> = fromJS([\n      {\n        a: 'a-1',\n        children: [\n          {\n            b: 'b-11',\n            children: [\n              {c: 'c-111'},\n              {c: 'c-112'},\n            ],\n          },\n        ],\n      },\n    ]);\n    \n    // hasIn()\uacfc getIn()\uc774 \ucd5c\ud558\uc704 API\ub77c\ub294\uac74 \ubaa8\ub4e0 \uc601\uc5ed\uc5d0\uc11c \uc0ac\uc6a9\uc774 \uac00\ub2a5\ud558\ub2e4\ub294 \uc774\uc57c\uae30...\n    expect(x.hasIn([0, 'children', 0, 'children', 0, 'c'])).toBeTruthy();\n    expect(x.getIn([0, 'children', 0, 'children', 0, 'c'])).toEqual('c-111');\n    expect(x.getIn([0, 'children', 0, 'children', 1, 'c'])).toEqual('c-112');\n  });\n  \n  it('Persistent changes', () => {\n    // Collection \ub2e8\uacc4\uc5d0\uc11c\ub294 \uadf8\ub9ac \ud070 \uc758\ubbf8\ub97c \uac00\uc9c0\ub294 API\ub294 \uc544\ub2cc \uac83 \uac19\ub2e4.\n    // update(K, (V) => V) \ub2e8\uacc4\ub85c \uac00\uc57c\uc9c0 \uc758\ubbf8\uac00 \uc0dd\uae38 \uac83 \uac19\ub2e4.\n    const x: Map<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    const y: number = x.update<number>((t: Map<string, number>) => t.size);\n    const z: Map<string, number> = x.update((t: Map<string, number>) => t.filter((i: number) => i < 2));\n    \n    expect(x.size).toEqual(3);\n    expect(y).toEqual(3);\n    expect(z.size).toEqual(1);\n  });\n  \n  it('Conversion to JavaScript types', () => {\n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    expect(indexed.toArray()).toEqual([1, 2, 3]);\n    expect(indexed.toObject()).toEqual({'0': 1, '1': 2, '2': 3}); // Index\uac00 \ubb38\uc790\ub85c \ub41c Object\uac00 \ub9cc\ub4e4\uc5b4\uc9c4\ub2e4\n    expect(indexed.toJSON()).toEqual([1, 2, 3]);\n    expect(indexed.toJS()).toEqual([1, 2, 3]);\n    \n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    expect(keyed.toArray()).toEqual([['a', 1], ['b', 2], ['c', 3]]);\n    expect(keyed.toObject()).toEqual({a: 1, b: 2, c: 3});\n    expect(keyed.toJSON()).toEqual({a: 1, b: 2, c: 3});\n    expect(keyed.toJS()).toEqual({a: 1, b: 2, c: 3});\n    \n    const tree: Collection<number, AMap> = fromJS([\n      {\n        a: 'a-1',\n        children: [\n          {\n            b: 'b-11',\n            children: [\n              {c: 'c-111'},\n              {c: 'c-112'},\n            ],\n          },\n        ],\n      },\n    ]);\n    \n    const arr: AMap[] = tree.toArray() as AMap[];\n    expect(Array.isArray(arr)).toBeTruthy();\n    expect(isKeyed(arr[0])).toBeTruthy();\n    expect(isIndexed(arr[0].get('children'))).toBeTruthy();\n    expect(arr[0].getIn(['children', 0, 'children', 0, 'c'])).toEqual('c-111');\n    \n    const obj: {[k: string]: AMap} = tree.toObject();\n    expect(isKeyed(obj['0'])).toBeTruthy();\n    expect(isIndexed(obj['0'].get('children'))).toBeTruthy();\n    expect(obj['0'].getIn(['children', 0, 'children', 0, 'c'])).toEqual('c-111');\n    \n    const json: AMap[] = tree.toJSON() as AMap[];\n    expect(Array.isArray(json)).toBeTruthy();\n    expect(isKeyed(json[0])).toBeTruthy();\n    expect(isIndexed(json[0].get('children'))).toBeTruthy();\n    expect(json[0].getIn(['children', 0, 'children', 0, 'c'])).toEqual('c-111');\n    \n    const js: A[] = tree.toJS() as A[];\n    expect(Array.isArray(js)).toBeTruthy();\n    expect(js[0].a).toEqual('a-1');\n    expect(Array.isArray(js[0].children)).toBeTruthy();\n    expect(js[0].children[0].children[0].c).toEqual('c-111');\n  });\n  \n  it('Iterators', () => {\n    // ES6 IterableIterator\ub97c return\ud55c\ub2e4.\n    // \ub2e8\uc21c\ud788 K, V \uc911 \ud558\ub098\ub97c Filtering \ud558\ub294 \uc6a9\ub3c4\ub098\n    // Iterator\ub97c \ubc1b\uc544\ub4e4\uc774\ub294 \uc678\ubd80 API\ub4e4\uacfc\uc758 \uc5f0\ub3d9\uc5d0 \uc0ac\uc6a9\ud560\ub9cc \ud558\uaca0\ub2e4.\n    \n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    \n    const indexedKeysIterator: IterableIterator<number> = indexed.keys();\n    expect(indexedKeysIterator.next()).toEqual({done: false, value: 0});\n    expect(indexedKeysIterator.next()).toEqual({done: false, value: 1});\n    expect(indexedKeysIterator.next()).toEqual({done: false, value: 2});\n    expect(indexedKeysIterator.next()).toEqual({done: true, value: undefined});\n    \n    const indexedValuesIterator: IterableIterator<number> = indexed.values();\n    expect(indexedValuesIterator.next()).toEqual({done: false, value: 1});\n    expect(indexedValuesIterator.next()).toEqual({done: false, value: 2});\n    expect(indexedValuesIterator.next()).toEqual({done: false, value: 3});\n    expect(indexedValuesIterator.next()).toEqual({done: true, value: undefined});\n    \n    const indexedEntriesIterator: IterableIterator<[number, number]> = indexed.entries();\n    expect(indexedEntriesIterator.next()).toEqual({done: false, value: [0, 1]});\n    expect(indexedEntriesIterator.next()).toEqual({done: false, value: [1, 2]});\n    expect(indexedEntriesIterator.next()).toEqual({done: false, value: [2, 3]});\n    expect(indexedEntriesIterator.next()).toEqual({done: true, value: undefined});\n    \n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    \n    const keyedKeysIterator: IterableIterator<string> = keyed.keys();\n    expect(keyedKeysIterator.next()).toEqual({done: false, value: 'a'});\n    expect(keyedKeysIterator.next()).toEqual({done: false, value: 'b'});\n    expect(keyedKeysIterator.next()).toEqual({done: false, value: 'c'});\n    expect(keyedKeysIterator.next()).toEqual({done: true, value: undefined});\n    \n    const keyedValuesIterator: IterableIterator<number> = keyed.values();\n    expect(keyedValuesIterator.next()).toEqual({done: false, value: 1});\n    expect(keyedValuesIterator.next()).toEqual({done: false, value: 2});\n    expect(keyedValuesIterator.next()).toEqual({done: false, value: 3});\n    expect(keyedValuesIterator.next()).toEqual({done: true, value: undefined});\n    \n    const keyedEntriesIterator: IterableIterator<[string, number]> = keyed.entries();\n    expect(keyedEntriesIterator.next()).toEqual({done: false, value: ['a', 1]});\n    expect(keyedEntriesIterator.next()).toEqual({done: false, value: ['b', 2]});\n    expect(keyedEntriesIterator.next()).toEqual({done: false, value: ['c', 3]});\n    expect(keyedEntriesIterator.next()).toEqual({done: true, value: undefined});\n  });\n  \n  it('Collections (Seq)', () => {\n    // Iterator\uc640 \uc720\uc0ac\ud558\uc9c0\ub9cc Seq\ub97c \ub0b4\ubcf4\ub0b4\uc900\ub2e4.\n    // Immutable \ud2b9\uc131\uc774 \ud544\uc694\ud558\ub2e4\uba74 \uc4f8\ub9cc \ud558\uaca0\ub2e4.\n    \n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    \n    const indexedKeySeq: Seq.Indexed<number> = indexed.keySeq();\n    expect(indexedKeySeq.get(0)).toEqual(0);\n    expect(indexedKeySeq.get(1)).toEqual(1);\n    expect(indexedKeySeq.get(2)).toEqual(2);\n    \n    const indexedValueSeq: Seq.Indexed<number> = indexed.valueSeq();\n    expect(indexedValueSeq.get(0)).toEqual(1);\n    expect(indexedValueSeq.get(1)).toEqual(2);\n    expect(indexedValueSeq.get(2)).toEqual(3);\n    \n    const indexedEntrySeq: Seq.Indexed<[number, number]> = indexed.entrySeq();\n    expect(indexedEntrySeq.get(0)).toEqual([0, 1]);\n    expect(indexedEntrySeq.get(1)).toEqual([1, 2]);\n    expect(indexedEntrySeq.get(2)).toEqual([2, 3]);\n    \n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    \n    const keyedKeySeq: Seq.Indexed<string> = keyed.keySeq();\n    expect(keyedKeySeq.get(0)).toEqual('a');\n    expect(keyedKeySeq.get(1)).toEqual('b');\n    expect(keyedKeySeq.get(2)).toEqual('c');\n    \n    const keyedValueSeq: Seq.Indexed<number> = keyed.valueSeq();\n    expect(keyedValueSeq.get(0)).toEqual(1);\n    expect(keyedValueSeq.get(1)).toEqual(2);\n    expect(keyedValueSeq.get(2)).toEqual(3);\n    \n    const keyedEntrySeq: Seq.Indexed<[string, number]> = keyed.entrySeq();\n    expect(keyedEntrySeq.get(0)).toEqual(['a', 1]);\n    expect(keyedEntrySeq.get(1)).toEqual(['b', 2]);\n    expect(keyedEntrySeq.get(2)).toEqual(['c', 3]);\n  });\n  \n  it('Conversion to Collections', () => {\n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    const set: Collection.Set<number> = Set<number>([1, 2, 3]);\n    \n    // {0..}\n    expect(indexed.toMap().equals(Map<number, number>([[0, 1], [1, 2], [2, 3]]))).toBeTruthy();\n    expect(indexed.toSet().equals(Set<number>([1, 2, 3]))).toBeTruthy();\n    expect(indexed.toStack().equals(Stack<number>([1, 2, 3]))).toBeTruthy();\n    \n    expect(keyed.toList().equals(List<number>([1, 2, 3]))).toBeTruthy();\n    expect(keyed.toSet().equals(Set<number>([1, 2, 3]))).toBeTruthy();\n    expect(keyed.toStack().equals(Stack<number>([1, 2, 3]))).toBeTruthy();\n    \n    // {1..}\n    expect(set.toMap().equals(Map<number, number>([[1, 1], [2, 2], [3, 3]]))).toBeTruthy();\n    expect(set.toList().equals(List<number>([1, 2, 3]))).toBeTruthy();\n    expect(set.toStack().equals(Stack<number>([1, 2, 3]))).toBeTruthy();\n  });\n  \n  it('Conversion to Seq', () => {\n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    const set: Collection.Set<number> = Set<number>([1, 2, 3]);\n    \n    // {0..}\n    // \uac19\uc9c0\ub9cc equals\ub294 false\ub85c \ub098\uc628\ub2e4\n    //console.log('Collection.test.ts..()', indexed.toKeyedSeq(), Seq.Keyed<number, number>([[0, 1], [1, 2], [2, 3]]));\n    //expect(indexed.toKeyedSeq().equals(Seq.Keyed<number, number>([[0, 1], [1, 2], [2, 3]]))).toBeTruthy();\n    expect(indexed.toSetSeq().equals(Seq.Set<number>([1, 2, 3]))).toBeTruthy();\n    \n    expect(keyed.toIndexedSeq().equals(Seq.Indexed<number>([1, 2, 3]))).toBeTruthy();\n    expect(keyed.toSetSeq().equals(Seq.Set<number>([1, 2, 3]))).toBeTruthy();\n    \n    // {1..}\n    // \uac19\uc9c0\ub9cc equals\ub294 false\ub85c \ub098\uc628\ub2e4\n    //console.log('Collection.test.ts..()', set.toKeyedSeq(), Seq.Keyed<number, number>([[1, 1], [2, 2], [3, 3]]));\n    //expect(set.toKeyedSeq().equals(Seq.Keyed<number, number>([[1, 1], [2, 2], [3, 3]]))).toBeTruthy();\n    expect(set.toIndexedSeq().equals(Seq.Indexed<number>([1, 2, 3]))).toBeTruthy();\n  });\n  \n  it('Sequence algorithms', () => {\n    // map, filter, sort \ubaa8\ub450 \uc798 \uc791\ub3d9\ub41c\ub2e4.\n    // \uc0ac\uc6a9\uc5d0 \uc8fc\uc800\ud560 \ud544\uc694\uac00 \uc5c6\ub2e4. \uc2ec\ub9ac\uc801\uc778 \uc7a5\ubcbd\uc744 \ud5c8\ubb3c\uc790.\n    \n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    \n    expect(\n      indexed\n        .map<string>((v: number) => 'a' + v)\n        .equals(List<string>(['a1', 'a2', 'a3'])),\n    ).toBeTruthy();\n    \n    expect(\n      indexed\n        .filter((v: number) => v > 2)\n        .equals(List<number>([3])),\n    ).toBeTruthy();\n    \n    expect(\n      indexed\n        .filterNot((v: number) => v > 2)\n        .equals(List<number>([1, 2])),\n    ).toBeTruthy();\n    \n    expect(indexed.reverse().equals(List<number>([3, 2, 1]))).toBeTruthy();\n    \n    expect(\n      indexed\n        .sort((a: number, b: number) => a > b ? -1 : 1)\n        .equals(List<number>([3, 2, 1])),\n    ).toBeTruthy();\n    \n    // Value Mapper\ub97c \uc0ac\uc6a9\ud574\uc11c \ube44\uad50\uac00 \ub420 \uc22b\uc790\ub97c \ub3c4\ucd9c\ud560 \uc218 \uc788\ub2e4.\n    // \uc190\uc5d0 \uc775\ud788\uba74 \ub3c4\uc6c0\uc774 \ub9ce\uc774 \ub420 \uac83 \uac19\ub2e4\n    expect(\n      List<{a: number}>([{a: 1}, {a: 2}, {a: 3}])\n        .sortBy<number>(\n          (v: {a: number}) => v.a,\n          (a: number, b: number) => a > b ? -1 : 1,\n        )\n        .toArray(),\n    ).toEqual([{a: 3}, {a: 2}, {a: 1}]);\n    \n    // \ud2b9\uc815 V\ub97c \ubc14\ud0d5\uc73c\ub85c Group\uc744 \ub9cc\ub4dc\ub294 \uc791\uc5c5. \uc758\uc678\ub85c \ub3c4\uc6c0\uc774 \ub9ce\uc774 \ub420 \uac83 \uac19\ub2e4.\n    expect(\n      List<{c: string, a: number}>([\n        {c: 'red', a: 1},\n        {c: 'red', a: 2},\n        {c: 'blue', a: 3},\n        {c: 'red', a: 4},\n        {c: 'blue', a: 5},\n      ])\n        .groupBy<string>((v: {c: string, a: number}) => v.c)\n        .toJS(),\n    ).toEqual({\n      red: [\n        {c: 'red', a: 1},\n        {c: 'red', a: 2},\n        {c: 'red', a: 4},\n      ],\n      blue: [\n        {c: 'blue', a: 3},\n        {c: 'blue', a: 5},\n      ],\n    });\n    \n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    \n    expect(\n      keyed\n        .map<string>((v: number, k: string) => k + v)\n        .equals(Map<string>({a: 'a1', b: 'b2', c: 'c3'})),\n    ).toBeTruthy();\n    \n    expect(\n      keyed\n        .filter((v: number, k: string) => v > 1)\n        .equals(Map<number>({b: 2, c: 3})),\n    ).toBeTruthy();\n    \n    expect(\n      keyed\n        .filterNot((v: number, k: string) => v > 1)\n        .equals(Map<number>({a: 1})),\n    ).toBeTruthy();\n    \n    expect(\n      keyed\n        .reverse()\n        .equals(keyed),\n    ).toBeTruthy();\n    // Collection.Keyed \uc5ed\uc2dc reverse(), sort(), sortBy() \uac00 \uc791\ub3d9\ud558\uc9c0\ub9cc \ud2b9\ubcc4\ud55c \uc758\ubbf8\uac00 \uc5c6\ub2e4\n    \n    // Indexed\uc640\ub294 \ub2e4\ub974\uac8c \ud558\uc704 \ub9ac\uc2a4\ud2b8\uac00 Keyed\uac00 \ub41c\ub2e4\n    expect(\n      Map<{c: string, v: number}>({\n        a: {c: 'red', v: 1},\n        b: {c: 'blue', v: 2},\n        c: {c: 'red', v: 3},\n        d: {c: 'blue', v: 4},\n        e: {c: 'red', v: 5},\n      })\n        .groupBy<string>((v: {c: string, v: number}) => v.c)\n        .toJS(),\n    ).toEqual({\n      red: {\n        a: {c: 'red', v: 1},\n        c: {c: 'red', v: 3},\n        e: {c: 'red', v: 5},\n      },\n      blue: {\n        b: {c: 'blue', v: 2},\n        d: {c: 'blue', v: 4},\n      },\n    });\n  });\n  \n  it('Side Effect', () => {\n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    const set: Collection.Set<number> = Set<number>([1, 2, 3]);\n    \n    indexed.forEach((v: number, k: number, iter: Collection<number, number>) => {\n      expect(typeof v).toEqual('number');\n      expect(typeof k).toEqual('number');\n      expect(iter).toEqual(indexed);\n    });\n    \n    keyed.forEach((v: number, k: string, iter: Collection.Keyed<string, number>) => {\n      expect(typeof v).toEqual('number');\n      expect(typeof k).toEqual('string');\n      expect(iter).toEqual(keyed);\n    });\n    \n    set.forEach((v: number, k: number, iter: Collection.Set<number>) => {\n      expect(typeof v).toEqual('number');\n      expect(typeof k).toEqual('number');\n      expect(iter).toEqual(set);\n    });\n  });\n  \n  it('Creating Subsets', () => {\n    // \uc21c\uc11c\ub97c \uae30\uc900\uc73c\ub85c \ud558\uae30 \ub54c\ubb38\uc5d0 Keyed\ub098 Set\uc740 \uc758\ubbf8\uac00 \uc5c6\uc744 \uac83 \uac19\ub2e4.\n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    \n    // \uc798\ub77c\ub0b4\uae30\n    expect(indexed.slice(2).equals(List<number>([3]))).toBeTruthy();\n    // \ucc98\uc74c\uc744 \uc81c\uc678\n    expect(indexed.rest().equals(List<number>([2, 3]))).toBeTruthy();\n    // \ub9c8\uc9c0\ub9c9\uc744 \uc81c\uc678\n    expect(indexed.butLast().equals(List<number>([1, 2]))).toBeTruthy();\n    \n    // \uc55e\uc758 \uba87 \uac1c\ub97c \uc81c\uc678\ud55c \ub098\uba38\uc9c0\n    expect(indexed.skip(2).equals(List([3]))).toBeTruthy();\n    // \ub4a4\uc758 \uba87 \uac1c\ub97c \uc81c\uc678\ud55c \ub098\uba38\uc9c0\n    expect(indexed.skipLast(2).equals(List([1]))).toBeTruthy();\n    // false \uc870\uac74\uc774 \ub098\uc628 \uc774\ud6c4\uc758 \uac83\ub4e4\n    expect(\n      indexed\n        .skipWhile((v: number) => v < 2)\n        .equals(List<number>([2, 3])),\n    ).toBeTruthy();\n    // true \uc870\uac74\uc774 \ub098\uc628 \uc774\ud6c4\uc758 \uac83\ub4e4\n    expect(\n      indexed\n        .skipUntil((v: number) => v > 2)\n        .equals(List<number>([3])),\n    ).toBeTruthy();\n    \n    // skip* \ubcf4\ub2e4\ub294 take*\uac00 \uc880 \ub354 \uc790\uc5f0\uc2a4\ub7ec\uc6b4 \ub17c\ub9ac\ub97c \uac00\uc9c4\ub2e4.\n    // \uac74\ub108\ub6f0\uae30 \ub17c\ub9ac\ub97c \uac00\uc9c4 skip* \ubcf4\ub2e4\ub294 take\ub97c \uc6b0\uc120 \uc0ac\uc6a9\ud560 \uc77c\uc774 \ub354 \ub9ce\uc744 \uac83 \uac19\ub2e4.\n    \n    // \uc55e\uc758 \uba87 \uac1c\n    expect(indexed.take(2).equals(List<number>([1, 2]))).toBeTruthy();\n    // \ub4a4\uc758 \uba87 \uac1c\n    expect(indexed.takeLast(2).equals(List<number>([2, 3]))).toBeTruthy();\n    // false \uc870\uac74\uc774 \ub098\uc62c\ub54c\uae4c\uc9c0 \uac00\uc838\uc628\ub2e4\n    expect(\n      indexed\n        .takeWhile((v: number) => v < 3)\n        .equals(List<number>([1, 2])),\n    ).toBeTruthy();\n    // true \uc870\uac74\uc774 \ub098\uc62c\ub54c\uae4c\uc9c0 \uac00\uc838\uc628\ub2e4\n    expect(\n      indexed\n        .takeUntil((v: number) => v > 1)\n        .equals(List<number>([1])),\n    ).toBeTruthy();\n  });\n  \n  it('Combination', () => {\n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    \n    // \ub2e4\ub978 List\ub97c concat \ud560 \uc218 \uc788\uace0\n    expect(\n      indexed\n        .concat(List<number>([4, 5]), List<number>([6, 7]))\n        .equals(List<number>([1, 2, 3, 4, 5, 6, 7])),\n    ).toBeTruthy();\n    \n    // Array\ub3c4 \uac00\ub2a5\n    expect(\n      indexed\n        .concat([4, 5], [6, 7])\n        .equals(List<number>([1, 2, 3, 4, 5, 6, 7])),\n    ).toBeTruthy();\n    \n    // Push\ucc98\ub7fc \ub123\uc744 \uc218\ub3c4 \uc788\uace0\n    expect(\n      indexed\n        .concat(4, 5, 6, 7)\n        .equals(List<number>([1, 2, 3, 4, 5, 6, 7])),\n    ).toBeTruthy();\n    \n    // Collection.Keyed\ub97c \ub123\uc744 \uacbd\uc6b0 V\uac12\ub4e4\ub9cc \uc0ac\uc6a9\ud574\uc11c \ud569\uce5c\ub2e4\n    expect(\n      indexed\n        .concat(Map<number>({a: 4, b: 5}).values())\n        .equals(List<number>([1, 2, 3, 4, 5])),\n    ).toBeTruthy();\n    \n    // Collection.Keyed\uc5d0\ub294 [K, V] \ud615\ud0dc\uc758 \uac12\ub4e4\ub9cc concat \ud560 \uc218 \uc788\ub2e4\n    expect(\n      keyed\n        .concat(Map<number>({d: 4, e: 5}), Map<number>({f: 6}))\n        .equals(Map<number>({a: 1, b: 2, c: 3, d: 4, e: 5, f: 6})),\n    ).toBeTruthy();\n    \n    // object\ub3c4 \uac00\ub2a5\n    expect(\n      keyed\n        .concat({d: 4, e: 5}, {f: 6})\n        .equals(Map<number>({a: 1, b: 2, c: 3, d: 4, e: 5, f: 6})),\n    ).toBeTruthy();\n    \n    // \uacc4\uce35\ud615 List\ub97c \ud3c9\ud310\ud654 \uc2dc\ud0a8\ub2e4\n    expect(\n      (fromJS([[1, 2, 3], [4, 5, 6], [7, 8]]) as List<List<number>>) // of List<List<number>>\n        .flatten()\n        .equals(List<number>([1, 2, 3, 4, 5, 6, 7, 8])),\n    ).toBeTruthy();\n    \n    // Depth\uac00 \uae4a\uc740 Tree\ub4e4\ub3c4 \ud569\uce5c\ub2e4\n    type ListTreeValue = (number | ListTree);\n    \n    interface ListTree extends List<ListTreeValue> {\n    }\n    \n    expect(\n      (fromJS([[[1, 2], [3]], [[4], [5, [6]]], [7, 8]]) as ListTree) // of List<...<number>>\n        .flatten()\n        .equals(List<number>([1, 2, 3, 4, 5, 6, 7, 8])),\n    ).toBeTruthy();\n    \n    // Shallow Depth = 1\n    expect(\n      (fromJS([[[1, 2], [3]], [[4, 5], [6]], [[7, 8]]]) as ListTree) // of List<List<List<number>>>\n        .flatten(true) // shallow = depth 1\n        .toJS(),\n    ).toEqual([[1, 2], [3], [4, 5], [6], [7, 8]]);\n    \n    // Depth \uc9c0\uc815\uc774 \uac00\ub2a5\n    expect(\n      (fromJS([[[1, 2], [3]], [[4, 5], [6]], [[7, 8]]]) as ListTree) // of List<List<List<number>>>\n        .flatten(1)\n        .toJS(),\n    ).toEqual([[1, 2], [3], [4, 5], [6], [7, 8]]);\n    \n    expect(\n      (fromJS([[[1, 2], [3]], [[4, 5], [6]], [[7, 8]]]) as ListTree) // of List<List<List<number>>>\n        .flatten(2)\n        .toJS(),\n    ).toEqual([1, 2, 3, 4, 5, 6, 7, 8]);\n    \n    // [K, V] Tree\uc758 \uacbd\uc6b0 \ucd5c\uc885\uc801\uc778 Leaf\ub9cc \uac00\uc838\uc640\uc11c flatten() \uc2dc\ud0a8\ub2e4\n    type MapTreeValue = (number | MapTree);\n    \n    interface MapTree extends Map<string, MapTreeValue> {\n    }\n    \n    expect(\n      (fromJS({a: {a1: 1, a2: 2}, b: {b1: 1, b2: 2}}) as MapTree)\n        .flatten()\n        .toJS(),\n    ).toEqual({a1: 1, a2: 2, b1: 1, b2: 2});\n    \n    expect(\n      (fromJS({a: {a1: {a11: 3, a12: {a121: 1}}, a2: 2}, b: {b1: 1, b2: 2}}) as MapTree)\n        .flatten()\n        .toJS(),\n    ).toEqual({a11: 3, a121: 1, a2: 2, b1: 1, b2: 2});\n    \n    // flatMap\uc740 map().flatten(1) \uacfc \uac19\ub2e4. \uadf8\ub9ac \uc0ac\uc6a9\ud560 \ucf00\uc774\uc2a4\uac00 \ub9ce\ub2e4\uace0 \ubcf4\uae34 \uc5b4\ub824\uc6b8 \uac83 \uac19\ub2e4.\n    expect(\n      (fromJS([[1, 2, 3], [4, 5, 6], [7, 8]]) as ListTree) // of List<List<number>>\n        .flatMap((v: List<number>) => {\n          return v.map((x: number) => 'a' + x);\n        })\n        .equals(List<string>(['a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8'])),\n    ).toBeTruthy();\n  });\n  \n  it('Search for value', () => {\n    // K \uae30\uc900, V \uae30\uc900 \uac80\uc0c9\uc774 \ubaa8\ub450 \uac00\ub2a5\ud558\uace0,\n    // \ub3cc\ub824\ubc1b\uc744 \uac12\ub3c4 K, V, [K, V] \ubaa8\ub450 \uac00\ub2a5\n    \n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    \n    expect(indexed.find(\n      (v: number) => v === 2,\n    )).toEqual(2);\n    \n    expect(indexed.find(\n      (v: number) => v === 6,\n      null,\n      10,\n    )).toEqual(10);\n    \n    expect(indexed.findLast(\n      (v: number) => v === 3,\n    )).toEqual(3);\n    \n    expect(indexed.findEntry(\n      (v: number) => v === 2,\n    )).toEqual([1, 2]);\n    \n    expect(indexed.findEntry(\n      (v: number) => v === 6,\n      null,\n      10,\n    )).toEqual(10); // notSetValue\uac00 [-1, 10]\uc774 \uc544\ub2c8\ub77c 10\uc73c\ub85c \ub4e4\uc5b4\uc628\ub2e4. \ubb38\uc81c \ub9ce\uc74c\n    \n    expect(indexed.findLastEntry(\n      (v: number) => v === 3,\n    )).toEqual([2, 3]);\n    \n    expect(indexed.findKey(\n      (v: number) => v === 2,\n    )).toEqual(1);\n    \n    expect(indexed.findKey(\n      (v: number) => v === 6,\n    )).toEqual(undefined);\n    \n    // (V) => K    V\ub97c \ub123\uc5b4\uc11c K\ub97c \uac00\uc838\uc628\ub2e4\n    expect(indexed.keyOf(2)).toEqual(1);\n    expect(indexed.lastKeyOf(3)).toEqual(2);\n    \n    expect(indexed.maxBy<number>(\n      (v: number) => v === 2 ? 100 : v,\n    )).toEqual(2);\n    \n    expect(\n      List<{a: number}>([{a: 1}, {a: 2}, {a: 3}])\n        .maxBy<number>((v: {a: number}) => v.a),\n    ).toEqual({a: 3});\n    \n    expect(keyed.find(\n      (v: number) => v === 2,\n    )).toEqual(2);\n    \n    expect(keyed.keyOf(2)).toEqual('b');\n  });\n  \n  it('Comparison', () => {\n    // \uc804\uccb4\uc640 \ubd80\ubd84\uc744 \ube44\uad50\ud560 \uc218 \uc788\ub2e4.\n    // \uc9d1\ud569 \ubb38\uc81c\ub97c \ub2e4\ub8f0\ub54c \ub3c4\uc6c0\uc774 \ub418\uaca0\ub2e4.\n    \n    expect(\n      List<number>([2, 3, 4])\n        .isSubset(List<number>([1, 2, 3, 4, 5, 6, 7])),\n    ).toBeTruthy();\n    \n    expect(\n      List<number>([2, 3, 4])\n        .isSubset([1, 2, 3, 4, 5, 6, 7]),\n    ).toBeTruthy();\n    \n    expect(\n      List<number>([1, 2, 3, 4, 5, 6, 7])\n        .isSuperset(List<number>([2, 3, 4])),\n    ).toBeTruthy();\n    \n    expect(\n      List<number>([1, 2, 3, 4, 5, 6, 7])\n        .isSuperset([2, 3, 4]),\n    ).toBeTruthy();\n    \n    //expect(\n    //  Map<number>({c: 3, d: 4})\n    //    .isSubset(Map<number>({a: 1, b: 2, c: 3, d: 4, e: 5})),\n    //).toBeTruthy();\n    \n    // \ube44\uad50 \ub300\uc0c1\uc774 Iterable\uc774\ub2e4 \ubcf4\ub2c8 Collection.Keyed\uc640 \ube44\uad50\ud560 \uc218 \uc5c6\ub2e4.\n    // Collection.Keyed\uc5d0\uc11c\ub294 \uc0ac\uc6a9\ud558\uae30 \uc560\ub9e4\ud558\uaca0\ub2e4.\n    \n    expect(\n      Map<number>({c: 3, d: 4})\n        .isSubset([1, 2, 3, 4, 5]),\n    ).toBeTruthy();\n  });\n});"},669:function(e,n,t){"use strict";t.r(n),n.default="import { Collection, List } from 'immutable';\n\ndescribe('Collection.Indexed', () => {\n  //it('Conversion to Seq', () => {\n  //  // ???? \ubb54 \u3146\u3142 \uc5d0\ub7ec\ub9cc \ub098\ub124\n  //  const indexed: Collection.Indexed<number> = List<number>([1, 2, 3, 4]);\n  //  console.log('Collection.Indexed.test.ts..()', indexed.fromEntrySeq());\n  //});\n  \n  it('Combination', () => {\n    const indexed: Collection.Indexed<number | string> = List<number>([1, 2, 3, 4]);\n    \n    // \ubaa8\ub4e0 Item\ub4e4\uc758 \uc911\uac04\uc5d0 \ud2b9\uc815 \uac12\uc744 \ub07c\uc6cc\ub123\ub294\ub2e4\n    // String Rows \ucc98\ub9ac \ub4f1 \uc774\ub798\uc800\ub798 \uc4f8\ub9cc\ud55c \ucf00\uc774\uc2a4\uac00 \uc788\uc744\ub4ef \uc2f6\uc740\ub370...\n    expect(\n      indexed\n        .interpose('/')\n        .toJS(),\n    ).toEqual([1, '/', 2, '/', 3, '/', 4]);\n    \n    // \ucd94\uac00\ub41c Item\ub4e4\uc744 \uc21c\ucc28\uc801\uc73c\ub85c \ubc30\uc5f4\ud55c\ub2e4\n    // [0, 3, 6]\n    // [1, 4, 8]\n    // [2, 5, 9]\n    // \uc640 \uac19\uc740 \uc21c\uc11c\uac00 \ub41c\ub2e4.\n    // \ucd94\uac00\uc801\uc73c\ub85c \ucd5c\uc18c Item \uc22b\uc790\uc5d0 \ub9de\ucdb0\uc9c0\uae30 \ub54c\ubb38\uc5d0 3, 4\uc640 9\uac00 \ub204\ub77d\ub41c\ub2e4.\n    expect(\n      indexed\n        .interleave(\n          List<number>([7, 8, 9]) as Collection<number, number>,\n          List<number>([100, 200]) as Collection<number, number>,\n        )\n        .toJS(),\n    ).toEqual([1, 7, 100, 2, 8, 200]);\n    \n    // Array.splice()\uc640 \ub3d9\uc77c\n    expect(\n      indexed\n        .splice(2, 1)\n        .toJS(),\n    ).toEqual([1, 2, 4]);\n    \n    // Collection.Indexed.interleave()\uc640 \ub3d9\uc77c\ud558\uc9c0\ub9cc\n    // 2\ucc28 \ubc30\uc5f4\ub85c \uac12\ub4e4\uc744 \ubb36\uc5b4\uc900\ub2e4\n    // \ub204\ub77d\ub8f0\uc740 \ub3d9\uc77c\n    expect(\n      indexed\n        .zip(\n          List<number>([7, 8, 9]) as Collection<number, number>,\n          List<number>([100, 200]) as Collection<number, number>,\n        )\n        .toJS(),\n    ).toEqual([[1, 7, 100], [2, 8, 200]]);\n    \n    // Collection.Indexed.zip()\uacfc \uc720\uc0ac\ud558\uc9c0\ub9cc\n    // 2\ucc28 \ubc30\uc5f4\ub85c \ubb36\uc5b4\ubc84\ub9ac\ub294 zip()\uacfc \ub2e4\ub974\uac8c \uc5b4\ub5bb\uac8c \ubb36\uc744\uc9c0 \uc790\uc758\uc801\uc73c\ub85c \uc120\ud0dd\ud560 \uc218 \uc788\ub2e4.\n    // Grid\uc640 \uac19\uc740 2\ucc28 \ubc30\uc5f4 Data\uc5d0\uc11c \ud569\uacc4\ub97c \ub0b8\ub2e4\uac70\ub098 \ud558\ub294\ub370 \uc720\uc6a9\ud560 \uac83 \uac19\ub2e4\n    expect(\n      indexed\n        .zipWith<string>(\n          (...values: (string | number)[]) => {\n            return values.join(':');\n          },\n          List<number>([100, 200]) as Collection<number, number>,\n          List<string>(['x', 'y']) as Collection<number, string>,\n          List<string>(['!', '@']) as Collection<number, string>,\n        )\n        .toJS(),\n    ).toEqual(['1:100:x:!', '2:200:y:@']);\n    \n    expect(\n      List<number>([1, 2, 3])\n        .zipWith<number>(\n          (...values: number[]) => {\n            return values.reduce((sum: number, v: number) => sum + v, 0);\n          },\n          List<number>([10, 20, 30]) as Collection<number, number>,\n          List<number>([100, 200, 300]) as Collection<number, number>,\n          List<number>([1000, 2000, 3000]) as Collection<number, number>,\n        )\n        .toJS(),\n    ).toEqual([1111, 2222, 3333]);\n  });\n  \n  it('Search for value', () => {\n    const indexed: Collection.Indexed<number | string> = List<number>([1, 2, 3, 4]);\n    \n    // Array.indexOf()\uc640 \ub3d9\uc77c\ud55c \uac83\ub4e4\n    expect(indexed.indexOf(2)).toEqual(1);\n    expect(indexed.lastIndexOf(3)).toEqual(2);\n    expect(indexed.findIndex((v: number | string) => v === 2)).toEqual(1);\n    expect(indexed.findLastIndex((v: number | string) => v === 3)).toEqual(2);\n  });\n});"},670:function(e,n,t){"use strict";t.r(n),n.default="import { Collection, Map } from 'immutable';\n\ndescribe('Collection.Keyed', () => {\n  it('Sequence functions', () => {\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3, d: 4});\n    \n    // [K, V] \ub97c [V, K]\ub85c \uc5ed\uc804 \uc2dc\ud0a8\ub2e4. Index \uc0dd\uc131\uc2dc\uc5d0 \ub3c4\uc6c0\uc774 \ub420 \uac83 \uac19\uae30\ub3c4 \ud558\uace0...\n    expect(\n      keyed\n        .flip()\n        .equals(Map<number, string>([[1, 'a'], [2, 'b'], [3, 'c'], [4, 'd']])),\n    ).toBeTruthy();\n  });\n  \n  it('Sequence algorithms', () => {\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3, d: 4});\n    \n    // K\ub97c \ubcc0\uc870\ud55c\ub2e4\n    expect(\n      keyed\n        .mapKeys((k: string) => 'x' + k)\n        .equals(Map<number>({xa: 1, xb: 2, xc: 3, xd: 4})),\n    ).toBeTruthy();\n    \n    // [K, V]\ub97c \ubaa8\ub450 \ubcc0\uc870\ud55c\ub2e4 (\uc774\uac8c \uc758\uc678\ub85c \uc4f8\ub9cc\ud560\ub4ef...)\n    expect(\n      keyed\n        .mapEntries((e: [string, number]) => ['x' + e[0], e[1] * 100])\n        .equals(Map<number>({xa: 100, xb: 200, xc: 300, xd: 400})),\n    ).toBeTruthy();\n  });\n});"},671:function(e,n,t){"use strict";t.r(n),n.default="import { List } from 'immutable';\n\ndescribe('List', () => {\n  it('Persistent changes', () => {\n    const list: List<number> = List<number>([1, 2, 3, 4]);\n    \n    expect(list.set(2, 100).toJS()).toEqual([1, 2, 100, 4]);\n    expect(list.set(4, 100).toJS()).toEqual([1, 2, 3, 4, 100]);\n    expect(list.set(5, 100).toJS()).toEqual([1, 2, 3, 4, undefined, 100]);\n    \n    expect(list.delete(0).toJS()).toEqual([2, 3, 4]);\n    expect(list.delete(2).toJS()).toEqual([1, 2, 4]);\n    expect(list.delete(5).toJS()).toEqual([1, 2, 3, 4]);\n    \n    expect(list.insert(2, 100).toJS()).toEqual([1, 2, 100, 3, 4]);\n    expect(list.insert(5, 100).toJS()).not.toEqual([1, 2, 3, 4, undefined, 100]);\n    expect(list.insert(5, 100).toJS()).toEqual([1, 2, 3, 4, 100]);\n    \n    expect(list.clear().size).toEqual(0);\n    \n    expect(list.push(5, 6).toJS()).toEqual([1, 2, 3, 4, 5, 6]);\n    expect(list.pop().toJS()).toEqual([1, 2, 3]);\n    \n    expect(list.unshift(5, 6).toJS()).toEqual([5, 6, 1, 2, 3, 4]);\n    expect(list.shift().toJS()).toEqual([2, 3, 4]);\n    \n    expect(\n      list\n        .update(2, (v: number) => v * 100)\n        .toJS(),\n    ).toEqual([1, 2, 300, 4]);\n    \n    expect(\n      list\n        .update(5, 9, (v: number) => v * 100)\n        .toJS(),\n    ).toEqual([1, 2, 3, 4, undefined, 900]);\n    \n    // concat()\uc774 \uc544\ub2c8\ub2e4. \uac19\uc740 Index\ub97c \ub36e\uc5b4\uc4f0\ub294 Merge\ub2e4.\n    // ??? concat()\uc774 \ub418\uc5b4\ubc84\ub838\ub294\ub370??? \u3146\u3142 \uc774\uac8c \ubb50\uc57c?\n    expect(\n      list\n        .merge(\n          List<number>([5, 6, 7]),\n          List<number>([100, 200]),\n        )\n        .toJS(),\n    ).toEqual([1, 2, 3, 4, 5, 6, 7, 100, 200]);\n    \n    //expect(\n    //  list\n    //    .mergeWith(\n    //      (oldVal, newVal) => {\n    //        return Math.max(oldVal, newVal);\n    //      },\n    //      List<number>([-1, -2, -3, -4, -5]),\n    //      List<number>([100, 200]),\n    //    )\n    //    .toJS(),\n    //).toEqual([100, 200, 3, 4, NaN]);\n  });\n  \n  //it('Deep persistent changes', () => {\n  //\n  //});\n});"},672:function(e,n,t){"use strict";t.r(n),n.default="import { fromJS, Map } from 'immutable';\nimport { AMap } from './Collection.test';\n\ndescribe('Map', () => {\n  it('Persistent changes', () => {\n    const map: Map<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    \n    expect(map.clear().size).toEqual(0);\n    expect(map.update('b', (b: number) => b * 100).get('b')).toEqual(200);\n    expect(map.update('z', 8, (z: number) => z * 100).get('z')).toEqual(800);\n    \n    expect(\n      map\n        .merge(Map<number>({d: 4, e: 5}))\n        .toJS(),\n    ).toEqual({a: 1, b: 2, c: 3, d: 4, e: 5});\n    \n    expect(\n      map\n        .merge({d: 4, e: 5})\n        .toJS(),\n    ).toEqual({a: 1, b: 2, c: 3, d: 4, e: 5});\n    \n    // Object.assign\uacfc \uac19\ub2e4. \ub4a4\uc5d0 \uc624\ub294 c\uac00 \ucd5c\uc885 \uacb0\uacfc\uc5d0 \ubc18\uc601\ub41c\ub2e4\n    expect(\n      map\n        .merge({c: 100, d: 4, e: 5})\n        .toJS(),\n    ).toEqual({a: 1, b: 2, c: 100, d: 4, e: 5});\n    \n    expect(\n      map\n        .mergeWith(\n          ((oldVal: number, newVal: number, k: string) => {\n            return oldVal > newVal ? oldVal : newVal; // 2. \uc911\ubcf5\uc744 \uc5b4\ub5bb\uac8c \ucc98\ub9ac\ud560\uc9c0 \uacb0\uc815\ud55c\ub2e4\n          }),\n          {c: 100, d: 4, e: 5}, // 1. \uc785\ub825\ub41c \uac12\ub4e4 \uc911 \uc911\ubcf5\uac12\uc774 \uc788\uc73c\uba74\n          {c: 300},\n          {c: 1000}, // 3. \uc911\ubcf5\ub41c \uac12\uc774 \uc5ec\ub7ec\ubc88\uc774\uba74 \uc5ec\ub7ec\ubc88 \uc2e4\ud589\ub41c\ub2e4\n        )\n        .toJS(),\n    ).toEqual({a: 1, b: 2, c: 1000, d: 4, e: 5});\n  });\n  \n  it('Transient changes', () => {\n    const map: Map<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    const tree: AMap = fromJS({\n      a: 'a-1',\n      children: [\n        {\n          b: 'b-11',\n          children: [\n            {c: 'c-111'},\n            {c: 'c-112'},\n          ],\n        },\n      ],\n    });\n    \n    // Mutable... \ub300\uc785\ud574\uc11c \uc0c8\ub85c\uc6b4 instance\uc744 \uc800\uc7a5\ud558\uc9c0 \uc54a\uc544\ub3c4 \ub41c\ub2e4.\n    // Bulk update\ub97c \uce60\ub54c \ub3c4\uc6c0\uc774 \ub420 \uac83 \uac19\ub2e4.\n    expect(\n      map\n        .withMutations((mutable: Map<string, number>) => {\n          mutable.set('a', 100);\n          mutable.set('c', 300);\n          return mutable;\n        })\n        .toJS(),\n    ).toEqual({\n      a: 100,\n      b: 2,\n      c: 300,\n    });\n    \n    // Tree \ub54c\ubb38\uc5d0 \uace0\ubbfc\ud558\uc9c0 \ub9d0\uace0 \uadf8\ub0e5 setIn()\uc744 \uc0ac\uc6a9\ud558\uba74 \ub418\uaca0\ub2e4\n    expect(\n      tree\n        .withMutations((mutable: AMap) => {\n          mutable.set('a', 'a-2');\n          mutable.setIn(['children', 0, 'children', 1, 'c'], 'c-xxx');\n          return mutable;\n        })\n        .toJS(),\n    ).toEqual({\n      a: 'a-2',\n      children: [\n        {\n          b: 'b-11',\n          children: [\n            {c: 'c-111'},\n            {c: 'c-xxx'},\n          ],\n        },\n      ],\n    });\n  });\n});"},673:function(e,n,t){"use strict";t.r(n),n.default="import { List, Stack } from 'immutable';\n\n// \ud6c4\uc785\uc120\ucd9c (LIFO) \uad6c\uc870 - \ub9c8\uc9c0\ub9c9\uc5d0 \ub4e4\uc5b4\uac04\uac8c \uc81c\uc77c \uba3c\uc800 \ub098\uc628\ub2e4\ndescribe('Stack', () => {\n  it('Reading values', () => {\n    const stack: Stack<number> = Stack<number>([1, 2, 3, 4]);\n    \n    // Collection.first()\uc640 \ub3d9\uc77c\n    expect(stack.peek()).toEqual(1);\n  });\n  \n  it('Persistent changes', () => {\n    const stack: Stack<number> = Stack<number>([1, 2, 3, 4]);\n    \n    expect(stack.clear().size).toEqual(0);\n    \n    // Stack \uad6c\uc870\uc774\uae30 \ub54c\ubb38\uc5d0 push, pushAll, pop\uc740 \uc5c6\ub294 \uac1c\ub150\uc774\ub2e4\n    // \uc55e\ub300\uac00\ub9ac\ub85c \uc9d1\uc5b4\ub123\uace0, peek()\uc73c\ub85c \uaebc\ub0b4\uac70\ub098 shift()\ub85c \uc81c\uac70\ud55c\ub2e4\n    expect(stack.unshift(5, 6).toJS()).toEqual([5, 6, 1, 2, 3, 4]);\n    expect(stack.push(5, 6).toJS()).toEqual([5, 6, 1, 2, 3, 4]);\n    \n    expect(stack.unshiftAll(List<number>([5, 6])).toJS()).toEqual([5, 6, 1, 2, 3, 4]);\n    expect(stack.pushAll(List<number>([5, 6])).toJS()).toEqual([5, 6, 1, 2, 3, 4]);\n    \n    expect(stack.shift().toJS()).toEqual([2, 3, 4]);\n    expect(stack.pop().toJS()).toEqual([2, 3, 4]);\n  });\n});"},674:function(e,n,t){"use strict";t.r(n),n.default="import { fromJS, Map } from 'immutable';\nimport { AMap } from './Collection.test';\n\ndescribe('Tree', () => {\n  it('Persistent changes', () => {\n    // \ubcf5\uc7a1\ud55c Tree\ub97c merge \ud560 \uc218 \uc788\ub2e4.\n    // \uae4a\uc740 \uc218\uc900\uae4c\uc9c0 \uc801\uc6a9\uc774 \ub41c\ub2e4\ub294\uac8c \ud3b8\ud560 \uac83 \uac19\ub2e4.\n    expect(\n      (fromJS({\n        a: 1,\n        b: {\n          b1: 10,\n        },\n      }) as Map<string, number | object>)\n        .mergeDeep(fromJS({\n          a: {\n            a1: 1,\n          },\n          b: {\n            b2: 100,\n            b3: {\n              b31: 1,\n            },\n          },\n          c: 10,\n        }))\n        .toJS(),\n    ).toEqual({\n      a: {\n        a1: 1,\n      },\n      b: {\n        b1: 10,\n        b2: 100,\n        b3: {\n          b31: 1,\n        },\n      },\n      c: 10,\n    });\n    \n    // \uae4a\uc740 \uc218\uc900\uc758 \ube44\uad50\ub97c \uc9c0\uc6d0\ud574\uc900\ub2e4\n    // K\uac00 Array\ub85c \uc654\uc73c\uba74 \ub354 \uc88b\uc558\uc744 \uac83 \uac19\uc740\ub370... \uc544\uc27d\ub124...\n    // \ubcf5\uc7a1\ud55c \uad6c\uc870\uccb4\uc758 Combine\uc774 \ud544\uc694\ud55c \uacbd\uc6b0 (ex. Tree\uc758 \uc77c\ubd80 \uac12\uc774 \ubcc0\uacbd\ub418\ub294 \uacbd\uc6b0?) \uc720\uc6a9\ud560 \uac83 \uac19\ub2e4.\n    // 1. {} \uc640 {} \uc758 \uacbd\uc6b0\uc5d0\ub294 \uc790\ub3d9\uc73c\ub85c \ud569\uce5c\ub2e4\n    // 2. V \uc640 V \uac00 \ucda9\ub3cc\ud558\ub294 \uacbd\uc6b0 \uc54c\ub9b0\ub2e4\n    // 3. V \uc640 {} \uac00 \ucda9\ub3cc\ud558\ub294 \uacbd\uc6b0 \uc54c\ub9b0\ub2e4\n    expect(\n      (fromJS({\n        a: {\n          a1: 10,\n          a2: 3,\n        },\n        b: {\n          b1: 10,\n          b3: {\n            b31: 100,\n          },\n        },\n      }) as Map<string, number | object>)\n        .mergeDeepWith(\n          (oldVal: number | object, newVal: number | object, k: string) => {\n            // a1 10 1\n            // a2 3 Map { \"a21\": 3 }\n            // b31 100 1\n            return typeof oldVal === 'number' && typeof newVal === 'number'\n              ? oldVal > newVal\n                ? oldVal\n                : newVal\n              : newVal;\n          },\n          fromJS({\n            a: {\n              a1: 1,\n              a2: {\n                a21: 3,\n              },\n            },\n            b: {\n              b2: 100,\n              b3: {\n                b31: 1,\n              },\n            },\n            c: 10,\n          }))\n        .toJS(),\n    ).toEqual({\n      a: {\n        a1: 10,\n        a2: {\n          a21: 3,\n        },\n      },\n      b: {\n        b1: 10,\n        b2: 100,\n        b3: {\n          b31: 100,\n        },\n      },\n      c: 10,\n    });\n  });\n  \n  it('Deep persistent changes', () => {\n    const tree: AMap = fromJS({\n      a: 'a-1',\n      children: [\n        {\n          b: 'b-11',\n          children: [\n            {c: 'c-111'},\n            {c: 'c-112'},\n          ],\n        },\n      ],\n    });\n    \n    expect(\n      tree\n        .setIn(['children', 0, 'children', 0, 'd'], 100)\n        .getIn(['children', 0, 'children', 0, 'd']),\n    ).toEqual(100);\n    \n    expect(\n      tree\n        .setIn(['children', 0, 'children', 0, 'c'], 'c-xxx')\n        .getIn(['children', 0, 'children', 0, 'c']),\n    ).toEqual('c-xxx');\n    \n    expect(\n      tree\n        .deleteIn(['children', 0, 'children', 0, 'c'])\n        .getIn(['children', 0, 'children', 0, 'c']),\n    ).toBeUndefined();\n    \n    // Indexed\ub97c \uc9c0\uc6b0\uba74 \ubc00\ub824\uc11c \uc62c\ub77c\uc628\ub2e4\n    expect(\n      tree\n        .deleteIn(['children', 0, 'children', 0])\n        .getIn(['children', 0, 'children', 0, 'c']),\n    ).toEqual('c-112');\n    \n    expect(\n      tree\n        .updateIn(['children', 0, 'children', 0, 'c'], (c: string) => c + '!!!')\n        .getIn(['children', 0, 'children', 0, 'c']),\n    ).toEqual('c-111!!!');\n    \n    // \ud2b9\uc815 Key Path\ub97c \uae30\uc900\uc73c\ub85c Merge\ub97c \uc791\ub3d9\uc2dc\ud0a8\ub2e4\n    // \uc77c\uc815 \uc601\uc5ed\uc758 \ub370\uc774\ud130\ub97c Update \ud560 \ub54c \ub3c4\uc6c0\uc774 \ub420 \uac83 \uac19\ub2e4.\n    // Deep\uc774 \uc544\ub2c8\uae30 \ub54c\ubb38\uc5d0 \ud2b9\uc815 Key Path\uc758 1\ub2e8\uacc4\ub9cc Merge \ub41c\ub2e4\n    expect(\n      (fromJS({\n        a: {\n          a1: 1,\n        },\n        b: {\n          b2: 100,\n          b3: {\n            b31: 1,\n            b32: 5,\n            b33: {\n              b332: 10,\n              b333: 4,\n            },\n          },\n        },\n        c: 10,\n      }) as Map<string, number | object>)\n        .mergeIn(\n          ['b', 'b3'],\n          fromJS({\n            b31: 100,\n            b33: {\n              b334: 100,\n            },\n          }),\n        )\n        .toJS(),\n    ).toEqual({\n      a: {\n        a1: 1,\n      },\n      b: {\n        b2: 100,\n        b3: {\n          b31: 100,\n          b32: 5,\n          b33: {\n            b334: 100,\n          },\n        },\n      },\n      c: 10,\n    });\n    \n    // Deep\uc774 \uc801\uc6a9\ub41c\ub2e4\n    expect(\n      (fromJS({\n        a: {\n          a1: 1,\n        },\n        b: {\n          b2: 100,\n          b3: {\n            b31: 1,\n            b32: 5,\n            b33: {\n              b332: 10,\n              b333: 4,\n            },\n          },\n        },\n        c: 10,\n      }) as Map<string, number | object>)\n        .mergeDeepIn(\n          ['b', 'b3'],\n          fromJS({\n            b31: 100,\n            b33: {\n              b334: 100,\n            },\n          }),\n        )\n        .toJS(),\n    ).toEqual({\n      a: {\n        a1: 1,\n      },\n      b: {\n        b2: 100,\n        b3: {\n          b31: 100,\n          b32: 5,\n          b33: {\n            b332: 10,\n            b333: 4,\n            b334: 100,\n          },\n        },\n      },\n      c: 10,\n    });\n  });\n});"}}]);