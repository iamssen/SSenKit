!function(e,n){for(var t in n)e[t]=n[t]}(exports,function(e){var n={};function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)t.d(r,o,function(n){return e[n]}.bind(null,o));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=34)}([function(e,n){e.exports=require("react")},function(e,n,t){"use strict";var r=t(5),o=(t(40),t(41),t(42),t(43),t(44),t(45),t(46),t(47),t(48),t(49),t(50),t(0)),a=t.n(o);function i(e){var n=e.value,t=e.children,o=e.language,i=void 0===o?"none":o;if(!t&&!n)return null;["javascript jsx"].indexOf(i)&&(i="jsx"),["typescript jsx"].indexOf(i)&&(i="tsx"),["sh"].indexOf(i)&&(i="bash"),r.languages[i]||(i="none");var l=r.languages[i]?r.languages[i]:r.languages.js,u=Object(r.highlight)(t||n,l),s="language-"+i;return a.a.createElement("pre",{className:s},a.a.createElement("code",{className:s,dangerouslySetInnerHTML:{__html:u}}))}var l=t(30),u=t.n(l);function s(e){var n=e.text,t=e.children;return a.a.createElement(u.a,{source:n||t,renderers:{code:i}})}t.d(n,"a",function(){return i}),t.d(n,"b",function(){return s})},function(e,n){e.exports=require("react-router")},function(e,n){e.exports=require("react-router-dom")},function(e,n){e.exports=require("react-intl")},function(e,n){e.exports=require("prismjs")},function(e,n){e.exports=require("locale-code")},function(e,n,t){"use strict";t.d(n,"a",function(){return l});var r=t(0),o=t(8);function a(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=[],r=!0,o=!1,a=void 0;try{for(var i,l=e[Symbol.iterator]();!(r=(i=l.next()).done)&&(t.push(i.value),!n||t.length!==n);r=!0);}catch(e){o=!0,a=e}finally{try{r||null==l.return||l.return()}finally{if(o)throw a}}return t}(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function i(e){var n=e.load,t=e.props,i=a(Object(r.useState)(null),2),l=i[0],u=i[1],s=Object(o.b)().setLoading;return Object(r.useEffect)(function(){s(!0),n.then(function(e){var n=e.default;u(Object(r.createElement)(n,t)),s(!1)})},[]),l}function l(e){return function(n){return Object(r.createElement)(i,{props:n,load:e()})}}},function(e,n,t){"use strict";t.d(n,"a",function(){return l}),t.d(n,"b",function(){return u});var r=t(0),o=t.n(r);function a(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=[],r=!0,o=!1,a=void 0;try{for(var i,l=e[Symbol.iterator]();!(r=(i=l.next()).done)&&(t.push(i.value),!n||t.length!==n);r=!0);}catch(e){o=!0,a=e}finally{try{r||null==l.return||l.return()}finally{if(o)throw a}}return t}(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var i=o.a.createContext({loading:!1,setLoading:function(e){}});function l(e){var n=e.children,t=e.fallback,l=a(Object(r.useState)(!1),2),u=l[0],s=l[1];return o.a.createElement(i.Provider,{value:{loading:u,setLoading:s}},n,u&&t)}function u(){return Object(r.useContext)(i)}},function(e,n,t){"use strict";var r=t(18);t.o(r,"SyncRouteStore")&&t.d(n,"SyncRouteStore",function(){return r.SyncRouteStore});t(19);var o=t(20);t.d(n,"SyncRouteStore",function(){return o.a});t(7),t(21);var a=t(8);t.d(n,"Suspense",function(){return a.a})},function(e,n,t){"use strict";t.d(n,"a",function(){return s}),t.d(n,"b",function(){return c});var r=t(0),o=t.n(r),a=t(4);function i(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=Object(r.createContext)(),u=Object(a.injectIntl)(function(e){var n=e.intl,t=e.children;return n,o.a.createElement(l.Provider,{value:n},t)});function s(e){var n=e.children,t=i(e,["children"]);return o.a.createElement(a.IntlProvider,t,o.a.createElement(u,null,n))}function c(){return Object(r.useContext)(l)}},function(e,n){e.exports=require("resize-observer-polyfill")},function(e,n){e.exports=require("antd/lib/layout")},function(e,n){e.exports=require("antd/lib/icon")},function(e,n){e.exports=require("antd/lib/menu")},function(e,n){e.exports=require("js-cookie")},function(e,n){e.exports=require("body-parser")},function(e,n,t){e.exports={header:"index_header__1ePqQ",content:"index_content__8EclH"}},function(e,n){},function(e,n,t){"use strict";t(0),t(2),t(7)},function(e,n,t){"use strict";t.d(n,"a",function(){return l});var r=t(0),o=t(2);function a(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}var l=function e(n){var t=this;!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),this.routes=n,this.preload=function(e){return Promise.resolve()},this.getRoute=function(e){var n=t.routes.find(function(n){return n.path===e});if(n)return Object(r.createElement)(o.Route,function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},r=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.forEach(function(n){i(e,n,t[n])})}return e}({},n,{key:e}));throw new Error("Can't find matched path. ".concat(e))},this.getAllRoutes=function(){return t.routes.map(function(e){var n=e.path;return t.getRoute(n)})},this.getRouteOptions=function(){return t.routes.map(function(e){e.component;return a(e,["component"])})}}},function(e,n,t){"use strict"},function(e,n,t){"use strict";t.r(n);var r=t(12),o=t.n(r),a=(t(35),t(36),t(0)),i=t.n(a),l=t(3),u=t(9);function s(){return i.a.createElement("div",null,"Loading...")}function c(e){var n=e.routeStore;return i.a.createElement(u.Suspense,{fallback:i.a.createElement(s,null)},i.a.createElement(l.Switch,null,n.getAllRoutes()))}var p=t(13),m=t.n(p),d=t(14),b=t.n(d),f=t(26),g=t.n(f),x=b.a.Item,h=b.a.SubMenu;function y(){var e=g()().location,n=Object(a.useMemo)(function(){return[e.pathname]},[e.pathname]);return i.a.createElement(b.a,{mode:"horizontal",selectedKeys:n,style:{lineHeight:"64px"}},i.a.createElement(x,{key:"/"},i.a.createElement(l.Link,{to:"/"},i.a.createElement(m.a,{type:"home"}))),i.a.createElement(h,{key:"/modules",title:i.a.createElement("span",null,i.a.createElement(m.a,{type:"tool"}),i.a.createElement("span",null,"Modules"))},["react-devdoc","react-router-store","use-react-intl","use-locale","use-timezone","use-restricted-input","react-virtual-scroller"].map(function(e){return i.a.createElement(x,{key:"/modules/"+e},i.a.createElement(l.Link,{to:"/modules/"+e},e))})),i.a.createElement(h,{key:"/research",title:i.a.createElement("span",null,i.a.createElement(m.a,{type:"experiment"}),i.a.createElement("span",null,"Research"))},["immer","numeral"].map(function(e){return i.a.createElement(x,{key:"/research/"+e},i.a.createElement(l.Link,{to:"/research/"+e},e))}),["immutable"].map(function(e){return i.a.createElement(x,{key:"/research/"+e},i.a.createElement(l.Link,{to:"/research/"+e},i.a.createElement("s",null,e)))})))}t(37);var v=t(17),S=t.n(v),E=o.a.Content,k=o.a.Header;function q(e){var n=e.routeStore;return i.a.createElement(o.a,null,i.a.createElement(k,{className:S.a.header},i.a.createElement(y,null)),i.a.createElement(E,{className:S.a.content},i.a.createElement(c,{routeStore:n})))}var w=t(27),C=t(4),L=t(28),T=t.n(L),M=t(29),j=t.n(M),R=t(15),P=t(6),I=t.n(P);function O(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=[],r=!0,o=!1,a=void 0;try{for(var i,l=e[Symbol.iterator]();!(r=(i=l.next()).done)&&(t.push(i.value),!n||t.length!==n);r=!0);}catch(e){o=!0,a=e}finally{try{r||null==l.return||l.return()}finally{if(o)throw a}}return t}(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function B(e){var n=(arguments.length>1&&void 0!==arguments[1]?arguments[1]:{}).cookieKey,t=void 0===n?"locale":n,r=O(Object(a.useState)(e),2),o=r[0],i=r[1];return{locale:o,updateLocale:Object(a.useCallback)(function(e){I.a.validate(e)&&(i(e),function(e){var n=(arguments.length>1&&void 0!==arguments[1]?arguments[1]:{}).cookieKey,t=void 0===n?"locale":n;I.a.validate(e)&&Object(R.set)(t,e)}(e,{cookieKey:t}))},[])}}var z,A=t(10);!function(e){e.locale="locale",e.timezone="timezone"}(z||(z={})),Object(C.addLocaleData)(T.a),Object(C.addLocaleData)(j.a);var K=Object(a.createContext)();function V(e){var n=e.children,t=B(e.currentLocale,{cookieKey:z.locale}),r=t.locale,o=t.updateLocale;return i.a.createElement(A.a,{locale:r.slice(0,2),messages:w[r]},i.a.createElement(K.Provider,{value:{locale:r,updateLocale:o}},n))}var J=["en-US","ko-KR"],H=new u.SyncRouteStore([{path:"/",exact:!0,component:t(38).default},{path:"/modules/react-devdoc",component:t(39).default},{path:"/modules/react-router-store",component:t(52).default},{path:"/modules/use-locale",component:t(54).default},{path:"/modules/use-react-intl",component:t(56).default},{path:"/modules/use-timezone",component:t(58).default},{path:"/modules/use-restricted-input",component:t(81).default},{path:"/modules/react-virtual-scroller",component:t(80).default},{path:"/research/immer",component:t(65).default},{path:"/research/immutable",component:t(68).default},{path:"/research/numeral",component:t(77).default}]),_=t(31),$=t(32),W=t(2),D=t(33),N=t.n(D);function F(e){return function(e){if(Array.isArray(e)){for(var n=0,t=new Array(e.length);n<e.length;n++)t[n]=e[n];return t}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function U(e,n){n.send(function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=e.cookies[z.locale]||e.acceptsLanguages.apply(e,F(J))||J[0],r=Object($.renderToString)(i.a.createElement(W.StaticRouter,{location:e.url,context:{}},i.a.createElement(V,{currentLocale:t},i.a.createElement(q,{routeStore:H}))));return Object(_.render)(N.a,{base:"/",body:r,initialState:JSON.stringify(n)})}(e))}t.d(n,"requestHandler",function(){return U})},function(e,n){e.exports=require("cookie-parser")},function(e,n){e.exports=require("express")},function(e,n){e.exports=require("moment-timezone")},function(e,n){e.exports=require("use-react-router")},function(e){e.exports={"en-US":{"app.main.text":"Main"},"ko-KR":{"app.main.text":"메인"}}},function(e,n){e.exports=require("react-intl/locale-data/en")},function(e,n){e.exports=require("react-intl/locale-data/ko")},function(e,n){e.exports=require("react-markdown")},function(e,n){e.exports=require("ejs")},function(e,n){e.exports=require("react-dom/server")},function(e,n){e.exports='<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=UTF-8>\n    <meta name="viewport" content="width=device-width, initial-scale=1">\n    <base href="/"/>\n    <link rel="stylesheet" type="text/css" href="vendor.css"/>\n    <link rel="stylesheet" type="text/css" href="style.css"/>\n    <title>SSENKIT</title>\n    <% if (locals.initialState) { %>\n      <script>\n        window.__INITIAL_STATE__ = <%- locals.initialState.replace(/</g, \'\\\\u003c\'); %>\n      <\/script>\n    <% } %>\n  </head>\n  \n  <body>\n    <div id="app"><%- (locals.body || \'\') %></div>\n  </body>\n  \n  <script src="vendor.js"><\/script>\n  <script src="style.js"><\/script>\n  \x3c!-- And if you use css themes you need require add their js files. --\x3e\n  <script src="app.js"><\/script>\n</html>'},function(e,n,t){"use strict";t.r(n);var r=t(16),o=t.n(r),a=t(23),i=t.n(a),l=t(24),u=t.n(l),s=t(25),c=t.n(s),p=Number(process.env.PORT||process.env.SSR_PORT||4100),m=u()();m.use(o.a.urlencoded({extended:!1})),m.use(o.a.json()),m.use(i()()),m.get("/",t(22).requestHandler),m.get("/*",t(22).requestHandler),m.listen(p,function(){console.log("SSR server started ".concat(p," [").concat(c()().format("HH:mm:ss"),"]"))})},function(e,n,t){},function(e,n,t){},function(e,n,t){},function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return i});var r=t(0),o=t.n(r),a=t(10);function i(){var e=Object(a.b)().formatMessage;return o.a.createElement("div",null,e({id:"app.main.text"}))}},function(e,n,t){"use strict";t.r(n);var r=t(0),o=t.n(r),a=t(1);n.default=function(){return o.a.createElement("div",null,o.a.createElement(a.b,{text:t(51)}))}},function(e,n){!function(e){var n={variable:[{pattern:/\$?\(\([\s\S]+?\)\)/,inside:{variable:[{pattern:/(^\$\(\([\s\S]+)\)\)/,lookbehind:!0},/^\$\(\(/],number:/\b0x[\dA-Fa-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee]-?\d+)?/,operator:/--?|-=|\+\+?|\+=|!=?|~|\*\*?|\*=|\/=?|%=?|<<=?|>>=?|<=?|>=?|==?|&&?|&=|\^=?|\|\|?|\|=|\?|:/,punctuation:/\(\(?|\)\)?|,|;/}},{pattern:/\$\([^)]+\)|`[^`]+`/,greedy:!0,inside:{variable:/^\$\(|^`|\)$|`$/}},/\$(?:[\w#?*!@]+|\{[^}]+\})/i]};e.languages.bash={shebang:{pattern:/^#!\s*\/bin\/bash|^#!\s*\/bin\/sh/,alias:"important"},comment:{pattern:/(^|[^"{\\])#.*/,lookbehind:!0},string:[{pattern:/((?:^|[^<])<<\s*)["']?(\w+?)["']?\s*\r?\n(?:[\s\S])*?\r?\n\2/,lookbehind:!0,greedy:!0,inside:n},{pattern:/(["'])(?:\\[\s\S]|\$\([^)]+\)|`[^`]+`|(?!\1)[^\\])*\1/,greedy:!0,inside:n}],variable:n.variable,function:{pattern:/(^|[\s;|&])(?:alias|apropos|apt-get|aptitude|aspell|awk|basename|bash|bc|bg|builtin|bzip2|cal|cat|cd|cfdisk|chgrp|chmod|chown|chroot|chkconfig|cksum|clear|cmp|comm|command|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|du|egrep|eject|enable|env|ethtool|eval|exec|expand|expect|export|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|getopts|git|grep|groupadd|groupdel|groupmod|groups|gzip|hash|head|help|hg|history|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|jobs|join|kill|killall|less|link|ln|locate|logname|logout|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|make|man|mkdir|mkfifo|mkisofs|mknod|more|most|mount|mtools|mtr|mv|mmv|nano|netstat|nice|nl|nohup|notify-send|npm|nslookup|open|op|passwd|paste|pathchk|ping|pkill|popd|pr|printcap|printenv|printf|ps|pushd|pv|pwd|quota|quotacheck|quotactl|ram|rar|rcp|read|readarray|readonly|reboot|rename|renice|remsync|rev|rm|rmdir|rsync|screen|scp|sdiff|sed|seq|service|sftp|shift|shopt|shutdown|sleep|slocate|sort|source|split|ssh|stat|strace|su|sudo|sum|suspend|sync|tail|tar|tee|test|time|timeout|times|touch|top|traceroute|trap|tr|tsort|tty|type|ulimit|umask|umount|unalias|uname|unexpand|uniq|units|unrar|unshar|uptime|useradd|userdel|usermod|users|uuencode|uudecode|v|vdir|vi|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yes|zip)(?=$|[\s;|&])/,lookbehind:!0},keyword:{pattern:/(^|[\s;|&])(?:let|:|\.|if|then|else|elif|fi|for|break|continue|while|in|case|function|select|do|done|until|echo|exit|return|set|declare)(?=$|[\s;|&])/,lookbehind:!0},boolean:{pattern:/(^|[\s;|&])(?:true|false)(?=$|[\s;|&])/,lookbehind:!0},operator:/&&?|\|\|?|==?|!=?|<<<?|>>|<=?|>=?|=~/,punctuation:/\$?\(\(?|\)\)?|\.\.|[{}[\];]/};var t=n.variable[1].inside;t.string=e.languages.bash.string,t.function=e.languages.bash.function,t.keyword=e.languages.bash.keyword,t.boolean=e.languages.bash.boolean,t.operator=e.languages.bash.operator,t.punctuation=e.languages.bash.punctuation,e.languages.shell=e.languages.bash}(Prism)},function(e,n){Prism.languages.css={comment:/\/\*[\s\S]*?\*\//,atrule:{pattern:/@[\w-]+?.*?(?:;|(?=\s*\{))/i,inside:{rule:/@[\w-]+/}},url:/url\((?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,selector:/[^{}\s][^{};]*?(?=\s*\{)/,string:{pattern:/("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},property:/[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,important:/\B!important\b/i,function:/[-a-z0-9]+(?=\()/i,punctuation:/[(){};:]/},Prism.languages.css.atrule.inside.rest=Prism.languages.css,Prism.languages.markup&&(Prism.languages.insertBefore("markup","tag",{style:{pattern:/(<style[\s\S]*?>)[\s\S]*?(?=<\/style>)/i,lookbehind:!0,inside:Prism.languages.css,alias:"language-css",greedy:!0}}),Prism.languages.insertBefore("inside","attr-value",{"style-attr":{pattern:/\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i,inside:{"attr-name":{pattern:/^\s*style/i,inside:Prism.languages.markup.tag.inside},punctuation:/^\s*=\s*['"]|['"]\s*$/,"attr-value":{pattern:/.+/i,inside:Prism.languages.css}},alias:"language-css"}},Prism.languages.markup.tag))},function(e,n){Prism.languages.json={property:/"(?:\\.|[^\\"\r\n])*"(?=\s*:)/i,string:{pattern:/"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,greedy:!0},number:/\b0x[\dA-Fa-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee][+-]?\d+)?/,punctuation:/[{}[\]);,]/,operator:/:/g,boolean:/\b(?:true|false)\b/i,null:/\bnull\b/i},Prism.languages.jsonp=Prism.languages.json},function(e,n){!function(e){var n=e.util.clone(e.languages.javascript);e.languages.jsx=e.languages.extend("markup",n),e.languages.jsx.tag.pattern=/<\/?(?:[\w.:-]+\s*(?:\s+(?:[\w.:-]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s{'">=]+|\{(?:\{(?:\{[^}]*\}|[^{}])*\}|[^{}])+\}))?|\{\.{3}[a-z_$][\w$]*(?:\.[a-z_$][\w$]*)*\}))*\s*\/?)?>/i,e.languages.jsx.tag.inside.tag.pattern=/^<\/?[^\s>\/]*/i,e.languages.jsx.tag.inside["attr-value"].pattern=/=(?!\{)(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">]+)/i,e.languages.insertBefore("inside","attr-name",{spread:{pattern:/\{\.{3}[a-z_$][\w$]*(?:\.[a-z_$][\w$]*)*\}/,inside:{punctuation:/\.{3}|[{}.]/,"attr-value":/\w+/}}},e.languages.jsx.tag),e.languages.insertBefore("inside","attr-value",{script:{pattern:/=(\{(?:\{(?:\{[^}]*\}|[^}])*\}|[^}])+\})/i,inside:{"script-punctuation":{pattern:/^=(?={)/,alias:"punctuation"},rest:e.languages.jsx},alias:"language-javascript"}},e.languages.jsx.tag);var t=function(e){return e?"string"==typeof e?e:"string"==typeof e.content?e.content:e.content.map(t).join(""):""},r=function(n){for(var o=[],a=0;a<n.length;a++){var i=n[a],l=!1;if("string"!=typeof i&&("tag"===i.type&&i.content[0]&&"tag"===i.content[0].type?"</"===i.content[0].content[0].content?o.length>0&&o[o.length-1].tagName===t(i.content[0].content[1])&&o.pop():"/>"===i.content[i.content.length-1].content||o.push({tagName:t(i.content[0].content[1]),openedBraces:0}):o.length>0&&"punctuation"===i.type&&"{"===i.content?o[o.length-1].openedBraces++:o.length>0&&o[o.length-1].openedBraces>0&&"punctuation"===i.type&&"}"===i.content?o[o.length-1].openedBraces--:l=!0),(l||"string"==typeof i)&&o.length>0&&0===o[o.length-1].openedBraces){var u=t(i);a<n.length-1&&("string"==typeof n[a+1]||"plain-text"===n[a+1].type)&&(u+=t(n[a+1]),n.splice(a+1,1)),a>0&&("string"==typeof n[a-1]||"plain-text"===n[a-1].type)&&(u=t(n[a-1])+u,n.splice(a-1,1),a--),n[a]=new e.Token("plain-text",u,null,u)}i.content&&"string"!=typeof i.content&&r(i.content)}};e.hooks.add("after-tokenize",function(e){("jsx"===e.language||"tsx"===e.language)&&r(e.tokens)})}(Prism)},function(e,n){Prism.languages.less=Prism.languages.extend("css",{comment:[/\/\*[\s\S]*?\*\//,{pattern:/(^|[^\\])\/\/.*/,lookbehind:!0}],atrule:{pattern:/@[\w-]+?(?:\([^{}]+\)|[^(){};])*?(?=\s*\{)/i,inside:{punctuation:/[:()]/}},selector:{pattern:/(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\([^{}]*\)|[^{};@])*?(?=\s*\{)/,inside:{variable:/@+[\w-]+/}},property:/(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/i,punctuation:/[{}();:,]/,operator:/[+\-*\/]/}),Prism.languages.insertBefore("less","punctuation",{function:Prism.languages.less.function}),Prism.languages.insertBefore("less","property",{variable:[{pattern:/@[\w-]+\s*:/,inside:{punctuation:/:/}},/@@?[\w-]+/],"mixin-usage":{pattern:/([{;]\s*)[.#](?!\d)[\w-]+.*?(?=[(;])/,lookbehind:!0,alias:"function"}})},function(e,n){!function(e){e.languages.sass=e.languages.extend("css",{comment:{pattern:/^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t]+.+)*/m,lookbehind:!0}}),e.languages.insertBefore("sass","atrule",{"atrule-line":{pattern:/^(?:[ \t]*)[@+=].+/m,inside:{atrule:/(?:@[\w-]+|[+=])/m}}}),delete e.languages.sass.atrule;var n=/\$[-\w]+|#\{\$[-\w]+\}/,t=[/[+*\/%]|[=!]=|<=?|>=?|\b(?:and|or|not)\b/,{pattern:/(\s+)-(?=\s)/,lookbehind:!0}];e.languages.insertBefore("sass","property",{"variable-line":{pattern:/^[ \t]*\$.+/m,inside:{punctuation:/:/,variable:n,operator:t}},"property-line":{pattern:/^[ \t]*(?:[^:\s]+ *:.*|:[^:\s]+.*)/m,inside:{property:[/[^:\s]+(?=\s*:)/,{pattern:/(:)[^:\s]+/,lookbehind:!0}],punctuation:/:/,variable:n,operator:t,important:e.languages.sass.important}}}),delete e.languages.sass.property,delete e.languages.sass.important,delete e.languages.sass.selector,e.languages.insertBefore("sass","punctuation",{selector:{pattern:/([ \t]*)\S(?:,?[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,?[^,\r\n]+)*)*/,lookbehind:!0}})}(Prism)},function(e,n){Prism.languages.scss=Prism.languages.extend("css",{comment:{pattern:/(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,lookbehind:!0},atrule:{pattern:/@[\w-]+(?:\([^()]+\)|[^(])*?(?=\s+[{;])/,inside:{rule:/@[\w-]+/}},url:/(?:[-a-z]+-)*url(?=\()/i,selector:{pattern:/(?=\S)[^@;{}()]?(?:[^@;{}()]|&|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}]+[:{][^}]+))/m,inside:{parent:{pattern:/&/,alias:"important"},placeholder:/%[-\w]+/,variable:/\$[-\w]+|#\{\$[-\w]+\}/}}}),Prism.languages.insertBefore("scss","atrule",{keyword:[/@(?:if|else(?: if)?|for|each|while|import|extend|debug|warn|mixin|include|function|return|content)/i,{pattern:/( +)(?:from|through)(?= )/,lookbehind:!0}]}),Prism.languages.scss.property={pattern:/(?:[\w-]|\$[-\w]+|#\{\$[-\w]+\})+(?=\s*:)/i,inside:{variable:/\$[-\w]+|#\{\$[-\w]+\}/}},Prism.languages.insertBefore("scss","important",{variable:/\$[-\w]+|#\{\$[-\w]+\}/}),Prism.languages.insertBefore("scss","function",{placeholder:{pattern:/%[-\w]+/,alias:"selector"},statement:{pattern:/\B!(?:default|optional)\b/i,alias:"keyword"},boolean:/\b(?:true|false)\b/,null:/\bnull\b/,operator:{pattern:/(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|or|not)(?=\s)/,lookbehind:!0}}),Prism.languages.scss.atrule.inside.rest=Prism.languages.scss},function(e,n){var t=Prism.util.clone(Prism.languages.typescript);Prism.languages.tsx=Prism.languages.extend("jsx",t)},function(e,n){Prism.languages.typescript=Prism.languages.extend("javascript",{keyword:/\b(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield|module|declare|constructor|namespace|abstract|require|type)\b/,builtin:/\b(?:string|Function|any|number|boolean|Array|symbol|console)\b/}),Prism.languages.ts=Prism.languages.typescript},function(e,n){Prism.languages.diff={coord:[/^(?:\*{3}|-{3}|\+{3}).*$/m,/^@@.*@@$/m,/^\d+.*$/m],deleted:/^[-<].*$/m,inserted:/^[+>].*$/m,diff:{pattern:/^!(?!!).+$/m,alias:"important"}}},function(e,n){Prism.languages.markdown=Prism.languages.extend("markup",{}),Prism.languages.insertBefore("markdown","prolog",{blockquote:{pattern:/^>(?:[\t ]*>)*/m,alias:"punctuation"},code:[{pattern:/^(?: {4}|\t).+/m,alias:"keyword"},{pattern:/``.+?``|`[^`\n]+`/,alias:"keyword"}],title:[{pattern:/\w+.*(?:\r?\n|\r)(?:==+|--+)/,alias:"important",inside:{punctuation:/==+$|--+$/}},{pattern:/(^\s*)#+.+/m,lookbehind:!0,alias:"important",inside:{punctuation:/^#+|#+$/}}],hr:{pattern:/(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,lookbehind:!0,alias:"punctuation"},list:{pattern:/(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,lookbehind:!0,alias:"punctuation"},"url-reference":{pattern:/!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,inside:{variable:{pattern:/^(!?\[)[^\]]+/,lookbehind:!0},string:/(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,punctuation:/^[\[\]!:]|[<>]/},alias:"url"},bold:{pattern:/(^|[^\\])(\*\*|__)(?:(?:\r?\n|\r)(?!\r?\n|\r)|.)+?\2/,lookbehind:!0,inside:{punctuation:/^\*\*|^__|\*\*$|__$/}},italic:{pattern:/(^|[^\\])([*_])(?:(?:\r?\n|\r)(?!\r?\n|\r)|.)+?\2/,lookbehind:!0,inside:{punctuation:/^[*_]|[*_]$/}},url:{pattern:/!?\[[^\]]+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)| ?\[[^\]\n]*\])/,inside:{variable:{pattern:/(!?\[)[^\]]+(?=\]$)/,lookbehind:!0},string:{pattern:/"(?:\\.|[^"\\])*"(?=\)$)/}}}}),Prism.languages.markdown.bold.inside.url=Prism.languages.markdown.url,Prism.languages.markdown.italic.inside.url=Prism.languages.markdown.url,Prism.languages.markdown.bold.inside.italic=Prism.languages.markdown.italic,Prism.languages.markdown.italic.inside.bold=Prism.languages.markdown.bold},function(e,n){e.exports="# Installation\n\n```\nnpm install react-devdoc\n```\n\nSimply `react-markdown` and `prismjs` wrapper components;\n\n# Usage\n\n```typescript jsx\nimport React from 'react';\nimport { Markdown, CodeBlock } from 'react-devdocs';\n\n// ⭐️ load prismjs theme\nimport 'prismjs/themes/prism-okaidia.css';\n\nimport { SampleComponent } from './sample';\n\nexport function Component() {\n  return (\n    <div>\n      {/* ⭐️ Set webpack *.md file loader to raw-loader */}\n      <Markdown text={require('!!raw-loader!./sample.md')}/>\n      <SampleComponent/>\n      {/* ⭐️ Get source code use raw-loader */}\n      <CodeBlock value={require('!!raw-loader!./sample')} language=\"tsx\"/>\n    </div> \n  );\n}\n```\n\n"},function(e,n,t){"use strict";t.r(n);var r=t(0),o=t.n(r),a=t(1);n.default=function(){return o.a.createElement("div",null,o.a.createElement(a.b,{text:t(53)}))}},function(e,n){e.exports="Installation\n===============================\n\n```\nnpm install react-router-store\n```\n\n`react-router-store` makes the `react-router` processing simpler for server side rendering.\n\nUsage\n===============================\n\nCreate async and sync route stores\n----------------------------------------\n\n```typescript\n// asyncRouteStore.ts\nimport { RouteStore, AsyncRouteStore } from 'react-router-store';\n\nexport const asyncRouteStore: RouteStore = new AsyncRouteStore([\n  {\n    path: '/',\n    exact: true,\n    component: () => import('./pages/main'),\n  },\n  {\n    path: '/sample',\n    component: () => import('./pages/sample'),\n  },\n]);\n```\n\n```typescript\n// syncRouteStore.ts\nimport { RouteStore, SyncRouteStore } from 'react-router-store';\n\nimport main from './pages/main';\nimport sample from './pages/sample'; \n\nexport const syncRouteStore: RouteStore = new SyncRouteStore([\n  {\n      path: '/',\n      exact: true,\n      component: main,\n    },\n    {\n      path: '/sample',\n      component: sample,\n    },\n]);\n```\n\nAdd `<Route/>`\n----------------------------------------\n\n```typescript jsx\n// main.tsx\nimport React from 'react';\nimport { RouteStore, Suspense } from 'react-router-store';\nimport { BrowserRouter, Route, Link, Switch } from 'react-router-dom';\n\ninterface MainProps {\n  routeStore: RouteStore;\n}\n\nfunction LoadingMessage() {\n  return <div>Loading...</div>;\n}\n\nexport function Main({ routeStore }: MainProps) {\n  return (\n    <div id=\"layout\">\n      <ul id=\"navigation\">\n        <li>\n          <Link to=\"/\">Home</Link>\n        </li>\n        <li>\n          <Link to=\"/sample\">Home</Link>\n        </li>\n      </ul>\n      \n      <div id=\"content\">\n        <Suspense fallback={<LoadingMessage/>}>\n          <Switch>\n            {/*<Route exact path=\"/\" component={}/>*/}\n            {/*<Route path=\"/sample\" component={}/>*/}\n            {routeStore.getAllRoutes()}\n          </Switch>\n        </Suspense>\n      </div>\n    </div>\n  )\n}\n```\n\nCreates entry files\n----------------------------------------\n\nCreates entry files for client and server.\n\n```typescript jsx\n// client.tsx\nimport React from 'react';\nimport { hydrate, render } from 'react-dom';\nimport { BrowserRouter, Route, Link } from 'react-router-dom';\n\nimport { asyncRouteStore } from './asyncRouteStore';\nimport { Main } from './main';\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Main routeStore={asyncRouteStore}/>\n    </BrowserRouter>\n  )\n}\n\nif (window.__INITIAL_STATE__) {\n  asyncRouteStore.preload(location.pathname).then(() => {\n    hydrate(<App/>, document.querySelector('#app'));\n  });\n} else {\n  render(<App/>, document.querySelector('#app'));\n}\n```\n\nFor client, preloads the route component before running the app.\n\n```typescript jsx\n// server.tsx\nimport React from 'react';\nimport { StaticRouter } from 'react-router';\nimport express, { Express, Request, Response } from 'express';\nimport { renderToString } from 'react-dom/server';\n\nimport { syncRouteStore } from './syncRouteStore';\nimport { Main } from './main';\n\nfunction renderHtml(url: string, initialState: object): string {\n  const htmlText: string = renderToString(\n    <StaticRouter location={url} context={{}}>\n      <Main routeStore={syncRouteStore}/>\n    </StaticRouter>\n  );\n  \n  return `\n    <html>\n      <head>\n        <meta charset=UTF-8>\n        <script>\n          window.__INITIAL_STATE__ = ${initialState.replace(/</g, '\\\\u003c')};\n        <\/script>\n      </head>\n      <body>\n        <div id=\"app\">${htmlText}</div>\n      </body>\n    </html>\n  `;\n}\n\nconst app: Express = express();\n\napp.get('/', (req: Request, res: Response) => {\n  res.send(renderHtml(req.url, {}));\n});\n\napp.get('/sample', (req: Request, res: Response) => {\n  res.send(renderHtml(req.url, {}));\n});\n\napp.listen(8080);\n```\n\nAdd a test\n----------------------------------------\n\nAdd a test to make sure both stores are set to the same options.\n\n```typescript\nimport { compareRouteOptions } from 'react-router-store';\nimport { asyncRouteStore } from './asyncRouteStore';\nimport { syncRouteStore } from './syncRouteStore';\n\ndescribe('/route', () => {\n  it('Should be matched all route options of stores', () => {\n    expect(compareRouteOptions(\n      asyncRouteStore.getRouteOptions(),\n      syncRouteStore.getRouteOptions(),\n    )).toBeTruthy();\n  });\n});\n```\n\n"},function(e,n,t){"use strict";t.r(n);var r=t(0),o=t.n(r),a=t(1);n.default=function(){return o.a.createElement("div",null,o.a.createElement(a.b,{text:t(55)}))}},function(e,n){e.exports="# Installation\n\n```\nnpm install use-locale\n```\n\n# API\n\n- `getBrowserLocale: ({cookieKey = 'locale', fallbackLanguageCodes = []}) => string`\n- `useLocale: (currentLocale: string, {cookieKey = 'locale'}) => { locale: string, updateLocale: (locale: string) => void }`\n\n# Basic usage\n\n```typescript jsx\nimport React from 'react';\nimport { useLocale, getBrowserLocale } from 'use-locale';\n\ntype LanguageCode = 'en-US' | 'ko-KR';\nconst languageCodes: LanguageCode[] = ['en-US', 'ko-KR'];\n\nexport function Component() {\n  const {locale, updateLocale} = useLocale<LanguageCode>(getBrowserLocale<LanguageCode>());\n  \n  return (\n    <div>\n      <div>\n        {locale}\n      </div>\n      \n      <ul>\n        {\n          languageCodes.map(languageCode => (\n            <li key={languageCode} onClick={() => updateLocale(languageCode)}>\n              {languageCode}\n            </li>\n          ))\n        }\n      </ul>\n    </div>\n  );\n}\n```\n\nBasic use of `useLocale()` is simple.\n\n# Wrapping with React 16.3 Context\n\nHowever, the locale information should be used globally in the application, it is wrapped using the React 16.3 Context API.\n\n```typescript\nexport type LanguageCode = 'en-US' | 'ko-KR';\nexport const languageCodes: LanguageCode[] = ['en-US', 'ko-KR'];\n```\n\n```typescript jsx\nimport React, { Consumer, Context, ReactNode, useContext, createContext } from 'react';\nimport { useLocale } from 'use-locale';\nimport { LanguageCode, languageCodes } from './locale';\n\nexport interface SampleContextProps {\n  currentLocale: string;\n  children: ReactNode;\n}\n\nexport interface SampleContextState {\n  locale: LanguageCode;\n  updateLocale: (locale: LanguageCode) => void;\n}\n\n// @ts-ignore\nconst SampleContext: Context<SampleContextState> = createContext<SampleContextState>();\n\nexport function SampleContextProvider({ currentLocale, children }: SampleContextProps) {\n  const { locale, updateLocale } = useLocale<LanguageCode>(currentLocale);\n  \n  return (\n    <SampleContext.Provider value={{\n      locale,\n      updateLocale,\n    }}>\n      {children}\n    </SampleContext.Provider>\n  );\n}\n\nexport function useSampleContextState(): SampleContextState {\n  return useContext(SampleContext);\n}\n\nexport const SampleContextConsumer: Consumer<SampleContextState> = SampleContext.Consumer;\n```\n\nFirst, make a context\n\n```typescript jsx\nimport React from 'react';\nimport { SampleContextProvider } from './sample-context';\nimport { LanguageCode } from './locale';\nimport { getBrowserLocale } from 'use-locale';\nimport { Main } from './main';\n\nexport function App() {\n  return (\n    <SampleContextProvider currentLocale={getBrowserLocale<LanguageCode>()}>\n      <Main/>\n    </SampleContextProvider>\n  )\n}\n```\n\nAnd wrap the application main in the provider \n\n```typescript jsx\nimport React from 'react';\nimport { useSampleContextState } from './sample-context';\nimport { LanguageCode, languageCodes } from './locale';\n\nexport function Component() {\n  const { locale, updateLocale } = useSampleContextState();\n  \n  return (\n    <div>\n      <div>\n        {locale}\n      </div>\n      \n      <ul>\n        {\n          languageCodes.map(languageCode => (\n            <li key={languageCode} onClick={() => updateLocale(languageCode)}>\n              {languageCode}\n            </li>\n          ))\n        }\n      </ul>\n    </div>\n  );\n}\n```\n\nYou can access the locale information from anywhere in the application through the hook\n\n# SSR\n\nAdditionally, the locale information in SSR (Server Side Rendering) can be obtained via a cookie\n\n```typescript jsx\nimport express, { Express, Request, Response } from 'express';\nimport { LanguageCode, languageCodes } from './locale';\n\nconst app: Express = express();\n\napp.get('/', (req, res) => {\n  const locale: LanguageCode = req.cookies['locale'] || req.acceptsLanguages(...languageCodes) || languageCodes[0];\n  \n  // res.send(ssr processed html text)\n});\n\napp.listen(8080);\n``` "},function(e,n,t){"use strict";t.r(n);var r=t(0),o=t.n(r),a=t(1);n.default=function(){return o.a.createElement("div",null,o.a.createElement(a.b,{text:t(57)}))}},function(e,n){e.exports="# Installation\n\n```\nnpm install use-react-intl\n```\n\nMakes `react-intl` to be used as a Function component hook.\n\nThis module can be used temporarily until `react-intl` supports the React 16.3 Context API.\n\nAfter that, it is better to use React 16.8 `useContext()` hook.\n\n# Usage\n\n```typescript jsx\nimport React from 'react';\nimport { IntlProvider } from 'use-react-intl';\nimport { App } from './app';\n\nexport function Main(locale: 'en' | 'ko', messages: {[messageId: string]: string}) {\n  return (\n    <IntlProvider locale={locale} messages={messages}>\n      <App/>\n    </IntlProvider>\n  )\n}\n```\n\nFirst, you need to add `<IntlProvider/>` to your app.\n\nIts usage is the same as `<IntlProvider/>` in `react-intl`.\n\n```typescript jsx\nimport React from 'react';\nimport { InjectedIntl } from 'react-intl';\nimport { useIntl } from 'use-react-intl';\n\nexport function Component() {\n  const intl: InjectedIntl = useIntl();\n  \n  return (\n    <span>\n      {intl.formatMessage({id: 'some.intl.text'})}\n    </span>\n  )\n}\n```\n\nThen, you can use a hook function `useIntl()`."},function(e,n,t){"use strict";t.r(n);var r=t(0),o=t.n(r),a=t(1);n.default=function(){return o.a.createElement("div",null,o.a.createElement(a.b,{text:t(59)}))}},function(e,n){e.exports="# Installation\n\n```\nnpm install use-timezone\n```\n\n# API\n\n```typescript\ninterface Timezone {\n  countryCode: string;\n  countryName: string;\n  zoneName: string;\n  gmtOffset: number;\n  timestamp: number;\n}\n```\n\n- `timezoneList: Timezone[]`\n- `getBrowserTimezone: (cookieKey: string = 'timezone') => string`\n- `useTimezone: (currentTimezone: string) => { timezone: Timezone, updateTimezone: (timezone: string | Timezone) => void }`\n\n# Basic usage\n\n```typescript jsx\nimport React from 'react';\nimport { Timezone, useTimezone, getBrowserTimezone, timezoneList } from 'use-timezone';\n\nexport function Component() {\n  const {timezone, updateTimezone} = useTimezone(getBrowserTimezone());\n  \n  return (\n    <div>\n      <div>\n        {JSON.stringify(timezone)}\n      </div>\n      \n      <ul>\n        {\n          timezoneList.map(optionTimezone => (\n            <li key={optionTimezone.zoneName} onClick={() => updateTimezone(optionTimezone)}>\n              {optionTimezone.zoneName}\n            </li>\n          ))\n        }\n      </ul>\n    </div>\n  );\n}\n```\n\nBasic use of `useTimezone()` is simple.\n\n# Wrapping with React 16.3 Context\n\nHowever, the timezone information should be used globally in the application, it is wrapped using the React 16.3 Context API.\n\n```typescript jsx\nimport React, { Consumer, Context, ReactNode, useContext, createContext } from 'react';\nimport { Timezone, useTimezone } from 'use-timezone';\n\nexport interface SampleContextProps {\n  currentTimezone: string;\n  children: ReactNode;\n}\n\nexport interface SampleContextState {\n  timezone: Timezone;\n  updateTimezone: (timezone: string | Timezone) => void;\n}\n\n// @ts-ignore\nconst SampleContext: Context<SampleContextState> = createContext<SampleContextState>();\n\nexport function SampleContextProvider({ currentTimezone, children }: SampleContextProps) {\n  const { timezone, updateTimezone } = useTimezone(currentTimezone);\n  \n  return (\n    <SampleContext.Provider value={{\n      timezone,\n      updateTimezone,\n    }}>\n      {children}\n    </SampleContext.Provider>\n  );\n}\n\nexport function useSampleContextState(): SampleContextState {\n  return useContext(SampleContext);\n}\n\nexport const SampleContextConsumer: Consumer<SampleContextState> = SampleContext.Consumer;\n```\n\nFirst, make a context\n\n```typescript jsx\nimport React from 'react';\nimport { SampleContextProvider } from './sample-context';\nimport { getBrowserTimezone } from 'use-timezone';\nimport { Main } from './main';\n\nexport function App() {\n  return (\n    <SampleContextProvider currentTimezone={getBrowserTimezone()}>\n      <Main/>\n    </SampleContextProvider>\n  )\n}\n```\n\nAnd wrap the application main in the provider \n\n```typescript jsx\nimport React from 'react';\nimport { useSampleContextState } from './sample-context';\nimport { Timezone, useTimezone, getBrowserTimezone, timezoneList } from 'use-timezone';\n\nexport function Component() {\n  const { timezone, updateTimezone } = useSampleContextState();\n  \n  return (\n    <div>\n      <div>\n        {JSON.stringify(timezone)}\n      </div>\n      \n      <ul>\n        {\n          timezoneList.map(optionTimezone => (\n            <li key={optionTimezone.zoneName} onClick={() => updateTimezone(optionTimezone)}>\n              {optionTimezone.zoneName}\n            </li>\n          ))\n        }\n      </ul>\n    </div>\n  );\n}\n```\n\nYou can access the timezone information from anywhere in the application through the hook\n\n# SSR\n\nAdditionally, the timezone information in SSR (Server Side Rendering) can be obtained via a cookie\n\n```typescript jsx\nimport express, { Express, Request, Response } from 'express';\n\nconst app: Express = express();\n\napp.get('/', (req, res) => {\n  const timezone: string = req.cookies['timezone'] || 'Asia/Seoul';\n  \n  // res.send(ssr processed html text)\n});\n\napp.listen(8080);\n``` "},function(e,n){e.exports="# Installation\n\n```\nnpm install use-restricted-input\n```\n\n# Usage\n\n```typescript jsx\nimport React, { ChangeEvent } from 'react';\nimport useRestrictedInput from 'use-restricted-input';\n\nexport function Component() {\n  const {onKeyPress} = useRestrictedInput('abcd0-9');\n  const [text, setText] = useState<string>('');\n  \n  const onChange: (event: ChangeEvent<HTMLInputElement>) => void = useCallback((event: ChangeEvent<HTMLInputElement>) => {\n    setText(event.target.value);\n  }, [setText]);\n  \n  return (\n    <div>\n      <input type=\"text\"\n             value={text}\n             onChange={onChange}\n             onKeyPress={onKeyPress}/>\n      <p>\n        text is \"{text}\"\n      </p>\n    </div>\n  );\n}\n```\n\n# API\n\n```\nuseRestrictedInput(availableCharacters: string | ((character: string) => boolean)): { onKeyPress: (event: KeyboardEvent<InputElement>) => void }\n```\n\n- param\n  - `availableCharacters: string | ((character: string) => boolean)`\n    - `a-z0-9` or `abcde0-4#$`\n    - `(character: string) => boolean`\n- return\n  - `onKeyPress: (event: KeyboardEvent<InputElement>) => void`"},function(e,n){e.exports="import React, { ChangeEvent, useCallback, useState } from 'react';\nimport useRestrictedInput from 'use-restricted-input';\n\nexport function Basic() {\n  const {onKeyPress} = useRestrictedInput('abcd0-9');\n  const [text, setText] = useState<string>('');\n  \n  const onChange: (event: ChangeEvent<HTMLInputElement>) => void = useCallback((event: ChangeEvent<HTMLInputElement>) => {\n    setText(event.target.value);\n  }, [setText]);\n  \n  return (\n    <div>\n      <input type=\"text\"\n             value={text}\n             onChange={onChange}\n             onKeyPress={onKeyPress}/>\n      <p>\n        text is \"{text}\"\n      </p>\n    </div>\n  );\n}"},function(e,n){e.exports="import React, { ChangeEvent, useCallback, useState } from 'react';\nimport useRestrictedInput from 'use-restricted-input';\n\nconst availableCharacters: Set<string> = new Set([\n  'a', 'b', 'c', 'd', '1', '2', '3', '@', '#',\n]);\n\nexport function Callback() {\n  const {onKeyPress} = useRestrictedInput((char: string) => availableCharacters.has(char));\n  const [text, setText] = useState<string>('');\n  \n  const onChange: (event: ChangeEvent<HTMLInputElement>) => void = useCallback((event: ChangeEvent<HTMLInputElement>) => {\n    setText(event.target.value);\n  }, [setText]);\n  \n  return (\n    <div>\n      <input type=\"text\"\n             value={text}\n             onChange={onChange}\n             onKeyPress={onKeyPress}/>\n      <p>\n        text is \"{text}\"\n      </p>\n    </div>\n  );\n}"},function(e,n){e.exports="import React, { RefObject, useState } from 'react';\nimport { VerticalScroll, VerticalScrollDrawerProps } from 'react-virtual-scroller';\n\nexport function VerticalScrollBasic() {\n  const [contentHeight, setContentHeight] = useState(Math.floor(Math.random() * 30000) + 10000);\n  const [viewportHeight, setViewportHeight] = useState(Math.floor(Math.random() * 10000) + 10000);\n  const [scrollPosition, setScrollPosition] = useState(0);\n  const [scrollRatio, setScrollRatio] = useState(0);\n  const [containerHeight, setContainerHeight] = useState(250);\n  \n  function setRandomValues() {\n    setContentHeight(Math.floor(Math.random() * 30000) + 10000);\n    setViewportHeight(Math.floor(Math.random() * 10000) + 10000);\n    setScrollPosition(0);\n    setScrollRatio(0);\n  }\n  \n  function setRandomContainerHeight() {\n    setContainerHeight(Math.floor(Math.random() * 300) + 30);\n  }\n  \n  function onScroll(nextScrollPosition: number, nextScrollRatio: number) {\n    setScrollPosition(nextScrollPosition);\n    setScrollRatio(nextScrollRatio);\n  }\n  \n  return (\n    <div>\n      <div style={{height: containerHeight}}>\n        <VerticalScroll contentHeight={contentHeight}\n                        viewportHeight={viewportHeight}\n                        scrollPosition={scrollPosition}\n                        marginTop={15}\n                        marginBottom={15}\n                        onScroll={onScroll}>\n          {\n            ({\n               containerRef,\n               thumbRef,\n               trackRef,\n               containerStyle,\n               thumbStyle,\n               trackStyle,\n             }: VerticalScrollDrawerProps) => (\n              <div ref={containerRef}\n                   style={{\n                     ...containerStyle,\n                     width: 10,\n                     height: '100%',\n                     backgroundColor: 'rgba(0, 0, 0, 0.3)',\n                   }}>\n                <div ref={trackRef as RefObject<HTMLDivElement>}\n                     style={{\n                       ...trackStyle,\n                       left: -5,\n                       right: -5,\n                       backgroundColor: 'rgba(0, 0, 0, 0.3)',\n                       border: 'rgba(0, 0, 0, 1)',\n                     }}/>\n                <div ref={thumbRef as RefObject<HTMLDivElement>}\n                     style={{\n                       ...thumbStyle,\n                       left: -10,\n                       right: -10,\n                       backgroundColor: 'rgba(0, 0, 0, 0.3)',\n                       border: 'rgba(0, 0, 0, 1)',\n                     }}/>\n              </div>\n            )\n          }\n        </VerticalScroll>\n      </div>\n  \n      <ul>\n        <li>scrollPosition: {scrollPosition}</li>\n        <li>scrollRatio: {scrollRatio}</li>\n        <li>contentHeight: {contentHeight}</li>\n        <li>viewportHeight: {viewportHeight}</li>\n      </ul>\n  \n      <div>\n        <button onClick={setRandomValues}>\n          set random values\n        </button>\n    \n        <button onClick={setRandomContainerHeight}>\n          set random container height\n        </button>\n      </div>\n    </div>\n  );\n}"},function(e,n){e.exports="import React, { RefObject, useState } from 'react';\nimport { HorizontalScroll, HorizontalScrollDrawerProps } from 'react-virtual-scroller';\n\nexport function HorizontalScrollBasic() {\n  const [contentWidth, setContentWidth] = useState(Math.floor(Math.random() * 30000) + 10000);\n  const [viewportWidth, setViewportWidth] = useState(Math.floor(Math.random() * 10000) + 10000);\n  const [scrollPosition, setScrollPosition] = useState(0);\n  const [scrollRatio, setScrollRatio] = useState(0);\n  const [containerWidth, setContainerWidth] = useState(250);\n  \n  function setRandomValues() {\n    setContentWidth(Math.floor(Math.random() * 30000) + 10000);\n    setViewportWidth(Math.floor(Math.random() * 10000) + 10000);\n    setScrollPosition(0);\n    setScrollRatio(0);\n  }\n  \n  function setRandomContainerWidth() {\n    setContainerWidth(Math.floor(Math.random() * 300) + 30);\n  }\n  \n  function onScroll(nextScrollPosition: number, nextScrollRatio: number) {\n    setScrollPosition(nextScrollPosition);\n    setScrollRatio(nextScrollRatio);\n  }\n  \n  return (\n    <div>\n      <div style={{width: containerWidth}}>\n        <HorizontalScroll contentWidth={contentWidth}\n                          viewportWidth={viewportWidth}\n                          scrollPosition={scrollPosition}\n                          marginLeft={15}\n                          marginRight={15}\n                          onScroll={onScroll}>\n          {\n            ({\n               containerRef,\n               thumbRef,\n               trackRef,\n               containerStyle,\n               thumbStyle,\n               trackStyle,\n             }: HorizontalScrollDrawerProps) => (\n              <div ref={containerRef}\n                   style={{\n                     ...containerStyle,\n                     width: '100%',\n                     height: 10,\n                     backgroundColor: 'rgba(0, 0, 0, 0.3)',\n                   }}>\n                <div ref={trackRef as RefObject<HTMLDivElement>}\n                     style={{\n                       ...trackStyle,\n                       top: -5,\n                       bottom: -5,\n                       backgroundColor: 'rgba(0, 0, 0, 0.3)',\n                       border: 'rgba(0, 0, 0, 1)',\n                     }}/>\n                <div ref={thumbRef as RefObject<HTMLDivElement>}\n                     style={{\n                       ...thumbStyle,\n                       top: -10,\n                       bottom: -10,\n                       backgroundColor: 'rgba(0, 0, 0, 0.3)',\n                       border: 'rgba(0, 0, 0, 1)',\n                     }}/>\n              </div>\n            )\n          }\n        </HorizontalScroll>\n      </div>\n      \n      <ul>\n        <li>scrollPosition: {scrollPosition}</li>\n        <li>scrollRatio: {scrollRatio}</li>\n        <li>contentWidth: {contentWidth}</li>\n        <li>viewportWidth: {viewportWidth}</li>\n      </ul>\n      \n      <div>\n        <button onClick={setRandomValues}>\n          set random values\n        </button>\n        \n        <button onClick={setRandomContainerWidth}>\n          set random container width\n        </button>\n      </div>\n    </div>\n  );\n}"},function(e,n,t){"use strict";t.r(n);var r=t(0),o=t.n(r),a=t(1);n.default=function(){return o.a.createElement("div",null,o.a.createElement(a.b,{text:t(66)}),o.a.createElement(a.a,{value:t(67),language:"typescript"}))}},function(e,n){e.exports="# immer\n\n1. `object`, `array`의 경우 완벽하게 작동한다\n2. `Set`, `Map`은 제대로 동작하지 않는다. `new Set(originSet)`과 같이 사용하는게 더 낫다\n3. `mobx`의 경우 `@observable.ref`를 사용해서 `Observable Array`로 전환되지 않게 처리하면 문제 없다"},function(e,n){e.exports="import produce from 'immer';\nimport { action, IValueDidChange, observable, observe } from 'mobx';\n\ndescribe('immer', () => {\n  it('Test Set, Map', () => {\n    const set1: Set<string> = new Set(['a', 'b', 'c']);\n    //const set2: Set<string> = produce(set1, (draft: Set<string>) => {\n    //  draft.delete('b');\n    //  draft.add('d');\n    //});\n    const set2: Set<string> = new Set<string>(set1);\n    set2.delete('b');\n    set2.add('d');\n    \n    expect(set1 === set2).toBeFalsy();\n    expect(Array.from(set1)).toEqual(['a', 'b', 'c']);\n    expect(Array.from(set2)).toEqual(['a', 'c', 'd']);\n    \n    const map1: Map<string, number> = new Map([['a', 1], ['b', 2], ['c', 3]]);\n    //const map2: Map<string, number> = produce(map1, (draft: Map<string, number>) => {\n    //  map2.delete('b');\n    //  map2.set('d', 4);\n    //});\n    const map2: Map<string, number> = new Map<string, number>(map1);\n    map2.delete('b');\n    map2.set('d', 4);\n    \n    expect(map1 === map2).toBeFalsy();\n    expect(Array.from(map1.keys())).toEqual(['a', 'b', 'c']);\n    expect(Array.from(map1.values())).toEqual([1, 2, 3]);\n    expect(Array.from(map2.keys())).toEqual(['a', 'c', 'd']);\n    expect(Array.from(map2.values())).toEqual([1, 3, 4]);\n  });\n  \n  it('Test basic', () => {\n    const arr: string[] = ['a', 'b', 'c'];\n    expect(produce(arr, (draft: string[]) => {\n      draft.push('d', 'e'); // ['a', 'b', 'c', 'd', 'e']\n      return draft;\n    })).toEqual(['a', 'b', 'c', 'd', 'e']);\n    \n    const obj: object = {a: 1, b: 2, c: 3};\n    expect(produce(obj, (draft: object) => {\n      draft['a'] = 3; // {a: 3, b: 2, c: 3}\n      delete draft['c']; // {a: 3, b: 2}\n      draft['d'] = 100; // {a: 3, b: 2, d: 100}\n      return draft;\n    })).toEqual({a: 3, b: 2, d: 100});\n    \n    const str: string = 'a';\n    expect(produce(str, (draft: string) => {\n      return draft + 'ccc'; // 'accc'\n    })).toEqual('accc');\n  });\n  \n  it('Test mobx', () => {\n    class Data {\n      // @observable.ref 를 사용해서 observable array로 변환되지 않도록 한다\n      @observable.ref arr: string[] = ['a', 'b', 'c'];\n      \n      @action update = (append: string) => {\n        this.arr = produce(this.arr, (draft: string[]) => {\n          draft.push(append);\n        });\n      };\n    }\n    \n    const data: Data = new Data();\n    \n    expect(Array.isArray(data.arr)).toBeTruthy();\n    expect(data.arr).toEqual(['a', 'b', 'c']);\n    \n    data.update('d');\n    \n    expect(Array.isArray(data.arr)).toBeTruthy();\n    expect(data.arr).toEqual(['a', 'b', 'c', 'd']);\n    \n    return new Promise((resolve: () => void) => {\n      observe(data, 'arr', ({oldValue, newValue}: IValueDidChange<string[]>) => {\n        expect(oldValue).toEqual(['a', 'b', 'c', 'd']);\n        expect(newValue).toEqual(['a', 'b', 'c', 'd', 'e']);\n        resolve();\n      });\n      \n      setTimeout(() => {\n        data.update('e');\n      }, 200);\n    });\n  });\n  \n  it('Test deep', () => {\n    const arr: (string | string[])[] = ['a', ['b', 'c']];\n    expect(produce(arr, (draft: (string | string[])[]) => {\n      (draft[1] as string[]).splice(1, 1); // ['a', ['b']]\n      (draft[1] as string[]).push('d'); // ['a', ['b', 'd']]\n      draft.push(['e']); // ['a', ['b', 'd'], ['e']]\n      draft.push('f'); // ['a', ['b', 'd'], ['e'], 'f']\n    })).toEqual(['a', ['b', 'd'], ['e'], 'f']);\n    \n    const obj: object = {\n      a: {\n        b: 1,\n        c: {\n          d: 2,\n        },\n      },\n      e: 3,\n    };\n    \n    expect(produce(obj, (draft: object) => {\n      delete draft['a']['b']; // {a: {c: {d: 2}}, e: 3}\n      draft['a']['c']['d'] = 5; // {a: {c: {d: 5}}, e: 3}\n      draft['a']['c']['f'] = {}; // {a: {c: {d: 5, f: {}}}, e: 3}\n      draft['a']['c']['f']['g'] = 4; // {a: {c: {d: 5, f: {g: 4}}}, e: 3}\n    })).toEqual({\n      a: {\n        c: {\n          d: 5,\n          f: {\n            g: 4,\n          },\n        },\n      },\n      e: 3,\n    });\n  });\n});"},function(e,n,t){"use strict";t.r(n);var r=t(0),o=t.n(r),a=t(1);n.default=function(){return o.a.createElement("div",null,o.a.createElement(a.b,{text:t(69)}),o.a.createElement("h2",null,"Collection"),o.a.createElement(a.a,{value:t(70),language:"typescript"}),o.a.createElement("h2",null,"Collection.Indexed"),o.a.createElement(a.a,{value:t(71),language:"typescript"}),o.a.createElement("h2",null,"Collection.Keyed"),o.a.createElement(a.a,{value:t(72),language:"typescript"}),o.a.createElement("h2",null,"List"),o.a.createElement(a.a,{value:t(73),language:"typescript"}),o.a.createElement("h2",null,"Map"),o.a.createElement(a.a,{value:t(74),language:"typescript"}),o.a.createElement("h2",null,"Stack"),o.a.createElement(a.a,{value:t(75),language:"typescript"}),o.a.createElement("h2",null,"Tree"),o.a.createElement(a.a,{value:t(76),language:"typescript"}))}},function(e,n){e.exports="# immutable\n\n1. API의 구조가 예전과 다르다 (`List.merge()`가 Overwrite가 아니라 Concat처럼 동작한다거나 `List.merge(Map)`의 기준이 `V`만 뽑아내는게 아니라 `[K, V]`를 뽑아낸다거나...)\n2. API 변화가 불안정하고, 오랫동안 작업되지 않고 있고... 사용하지 않는게 좋겠다. (`immer`로 대체)"},function(e,n){e.exports="import { Collection, fromJS, isIndexed, isKeyed, List, Map, Seq, Set, Stack } from 'immutable';\n\nexport interface C {\n  c: string;\n}\n\nexport interface B {\n  b: string;\n  children: C[];\n}\n\nexport interface A {\n  a: string;\n  children: B[];\n}\n\n// Map Type은 K에 keyof만 사용하고, V는 별개로 지정하는게 좋을 것 같다.\n// as를 써야하겠지만 이 방식이 제일 간단할 것 같다.\nexport type CMap = Map<keyof C, string>;\nexport type BMap = Map<keyof B, string | List<CMap>>;\nexport type AMap = Map<keyof A, string | List<BMap>>;\n\ndescribe('Collection', () => {\n  it('Reading Values', () => {\n    const x: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    \n    expect(x.get(0)).toEqual(1);\n    expect(x.get(1)).toEqual(2);\n    expect(x.get(2)).toEqual(3);\n    expect(x.get(3)).toBeUndefined();\n    expect(x.get<number>(3, 8)).toEqual(8); // using not set value\n    \n    expect(x.has(0)).toBeTruthy();\n    expect(x.has(1)).toBeTruthy();\n    expect(x.has(2)).toBeTruthy();\n    expect(x.has(3)).toBeFalsy();\n    \n    // Collection에 특정 V가 들어있는지 확인할 수 있다\n    expect(x.contains(1)).toBeTruthy();\n    expect(x.contains(2)).toBeTruthy();\n    expect(x.contains(3)).toBeTruthy();\n    expect(x.contains(4)).toBeFalsy();\n    \n    expect(x.includes(1)).toBeTruthy();\n    expect(x.includes(2)).toBeTruthy();\n    expect(x.includes(3)).toBeTruthy();\n    expect(x.includes(4)).toBeFalsy();\n    \n    // 처음 / 마지막 값을 가져오기\n    // arr[arr.length - 1] 를 좀 더 세련되게 대체할 수 있겠다\n    expect(x.first()).toEqual(1);\n    expect(x.last()).toEqual(3);\n  });\n  \n  it('Reading deep values', () => {\n    const x: Collection<number, AMap> = fromJS([\n      {\n        a: 'a-1',\n        children: [\n          {\n            b: 'b-11',\n            children: [\n              {c: 'c-111'},\n              {c: 'c-112'},\n            ],\n          },\n        ],\n      },\n    ]);\n    \n    // hasIn()과 getIn()이 최하위 API라는건 모든 영역에서 사용이 가능하다는 이야기...\n    expect(x.hasIn([0, 'children', 0, 'children', 0, 'c'])).toBeTruthy();\n    expect(x.getIn([0, 'children', 0, 'children', 0, 'c'])).toEqual('c-111');\n    expect(x.getIn([0, 'children', 0, 'children', 1, 'c'])).toEqual('c-112');\n  });\n  \n  it('Persistent changes', () => {\n    // Collection 단계에서는 그리 큰 의미를 가지는 API는 아닌 것 같다.\n    // update(K, (V) => V) 단계로 가야지 의미가 생길 것 같다.\n    const x: Map<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    const y: number = x.update<number>((t: Map<string, number>) => t.size);\n    const z: Map<string, number> = x.update((t: Map<string, number>) => t.filter((i: number) => i < 2));\n    \n    expect(x.size).toEqual(3);\n    expect(y).toEqual(3);\n    expect(z.size).toEqual(1);\n  });\n  \n  it('Conversion to JavaScript types', () => {\n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    expect(indexed.toArray()).toEqual([1, 2, 3]);\n    expect(indexed.toObject()).toEqual({'0': 1, '1': 2, '2': 3}); // Index가 문자로 된 Object가 만들어진다\n    expect(indexed.toJSON()).toEqual([1, 2, 3]);\n    expect(indexed.toJS()).toEqual([1, 2, 3]);\n    \n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    expect(keyed.toArray()).toEqual([['a', 1], ['b', 2], ['c', 3]]);\n    expect(keyed.toObject()).toEqual({a: 1, b: 2, c: 3});\n    expect(keyed.toJSON()).toEqual({a: 1, b: 2, c: 3});\n    expect(keyed.toJS()).toEqual({a: 1, b: 2, c: 3});\n    \n    const tree: Collection<number, AMap> = fromJS([\n      {\n        a: 'a-1',\n        children: [\n          {\n            b: 'b-11',\n            children: [\n              {c: 'c-111'},\n              {c: 'c-112'},\n            ],\n          },\n        ],\n      },\n    ]);\n    \n    const arr: AMap[] = tree.toArray() as AMap[];\n    expect(Array.isArray(arr)).toBeTruthy();\n    expect(isKeyed(arr[0])).toBeTruthy();\n    expect(isIndexed(arr[0].get('children'))).toBeTruthy();\n    expect(arr[0].getIn(['children', 0, 'children', 0, 'c'])).toEqual('c-111');\n    \n    const obj: {[k: string]: AMap} = tree.toObject();\n    expect(isKeyed(obj['0'])).toBeTruthy();\n    expect(isIndexed(obj['0'].get('children'))).toBeTruthy();\n    expect(obj['0'].getIn(['children', 0, 'children', 0, 'c'])).toEqual('c-111');\n    \n    const json: AMap[] = tree.toJSON() as AMap[];\n    expect(Array.isArray(json)).toBeTruthy();\n    expect(isKeyed(json[0])).toBeTruthy();\n    expect(isIndexed(json[0].get('children'))).toBeTruthy();\n    expect(json[0].getIn(['children', 0, 'children', 0, 'c'])).toEqual('c-111');\n    \n    const js: A[] = tree.toJS() as A[];\n    expect(Array.isArray(js)).toBeTruthy();\n    expect(js[0].a).toEqual('a-1');\n    expect(Array.isArray(js[0].children)).toBeTruthy();\n    expect(js[0].children[0].children[0].c).toEqual('c-111');\n  });\n  \n  it('Iterators', () => {\n    // ES6 IterableIterator를 return한다.\n    // 단순히 K, V 중 하나를 Filtering 하는 용도나\n    // Iterator를 받아들이는 외부 API들과의 연동에 사용할만 하겠다.\n    \n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    \n    const indexedKeysIterator: IterableIterator<number> = indexed.keys();\n    expect(indexedKeysIterator.next()).toEqual({done: false, value: 0});\n    expect(indexedKeysIterator.next()).toEqual({done: false, value: 1});\n    expect(indexedKeysIterator.next()).toEqual({done: false, value: 2});\n    expect(indexedKeysIterator.next()).toEqual({done: true, value: undefined});\n    \n    const indexedValuesIterator: IterableIterator<number> = indexed.values();\n    expect(indexedValuesIterator.next()).toEqual({done: false, value: 1});\n    expect(indexedValuesIterator.next()).toEqual({done: false, value: 2});\n    expect(indexedValuesIterator.next()).toEqual({done: false, value: 3});\n    expect(indexedValuesIterator.next()).toEqual({done: true, value: undefined});\n    \n    const indexedEntriesIterator: IterableIterator<[number, number]> = indexed.entries();\n    expect(indexedEntriesIterator.next()).toEqual({done: false, value: [0, 1]});\n    expect(indexedEntriesIterator.next()).toEqual({done: false, value: [1, 2]});\n    expect(indexedEntriesIterator.next()).toEqual({done: false, value: [2, 3]});\n    expect(indexedEntriesIterator.next()).toEqual({done: true, value: undefined});\n    \n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    \n    const keyedKeysIterator: IterableIterator<string> = keyed.keys();\n    expect(keyedKeysIterator.next()).toEqual({done: false, value: 'a'});\n    expect(keyedKeysIterator.next()).toEqual({done: false, value: 'b'});\n    expect(keyedKeysIterator.next()).toEqual({done: false, value: 'c'});\n    expect(keyedKeysIterator.next()).toEqual({done: true, value: undefined});\n    \n    const keyedValuesIterator: IterableIterator<number> = keyed.values();\n    expect(keyedValuesIterator.next()).toEqual({done: false, value: 1});\n    expect(keyedValuesIterator.next()).toEqual({done: false, value: 2});\n    expect(keyedValuesIterator.next()).toEqual({done: false, value: 3});\n    expect(keyedValuesIterator.next()).toEqual({done: true, value: undefined});\n    \n    const keyedEntriesIterator: IterableIterator<[string, number]> = keyed.entries();\n    expect(keyedEntriesIterator.next()).toEqual({done: false, value: ['a', 1]});\n    expect(keyedEntriesIterator.next()).toEqual({done: false, value: ['b', 2]});\n    expect(keyedEntriesIterator.next()).toEqual({done: false, value: ['c', 3]});\n    expect(keyedEntriesIterator.next()).toEqual({done: true, value: undefined});\n  });\n  \n  it('Collections (Seq)', () => {\n    // Iterator와 유사하지만 Seq를 내보내준다.\n    // Immutable 특성이 필요하다면 쓸만 하겠다.\n    \n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    \n    const indexedKeySeq: Seq.Indexed<number> = indexed.keySeq();\n    expect(indexedKeySeq.get(0)).toEqual(0);\n    expect(indexedKeySeq.get(1)).toEqual(1);\n    expect(indexedKeySeq.get(2)).toEqual(2);\n    \n    const indexedValueSeq: Seq.Indexed<number> = indexed.valueSeq();\n    expect(indexedValueSeq.get(0)).toEqual(1);\n    expect(indexedValueSeq.get(1)).toEqual(2);\n    expect(indexedValueSeq.get(2)).toEqual(3);\n    \n    const indexedEntrySeq: Seq.Indexed<[number, number]> = indexed.entrySeq();\n    expect(indexedEntrySeq.get(0)).toEqual([0, 1]);\n    expect(indexedEntrySeq.get(1)).toEqual([1, 2]);\n    expect(indexedEntrySeq.get(2)).toEqual([2, 3]);\n    \n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    \n    const keyedKeySeq: Seq.Indexed<string> = keyed.keySeq();\n    expect(keyedKeySeq.get(0)).toEqual('a');\n    expect(keyedKeySeq.get(1)).toEqual('b');\n    expect(keyedKeySeq.get(2)).toEqual('c');\n    \n    const keyedValueSeq: Seq.Indexed<number> = keyed.valueSeq();\n    expect(keyedValueSeq.get(0)).toEqual(1);\n    expect(keyedValueSeq.get(1)).toEqual(2);\n    expect(keyedValueSeq.get(2)).toEqual(3);\n    \n    const keyedEntrySeq: Seq.Indexed<[string, number]> = keyed.entrySeq();\n    expect(keyedEntrySeq.get(0)).toEqual(['a', 1]);\n    expect(keyedEntrySeq.get(1)).toEqual(['b', 2]);\n    expect(keyedEntrySeq.get(2)).toEqual(['c', 3]);\n  });\n  \n  it('Conversion to Collections', () => {\n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    const set: Collection.Set<number> = Set<number>([1, 2, 3]);\n    \n    // {0..}\n    expect(indexed.toMap().equals(Map<number, number>([[0, 1], [1, 2], [2, 3]]))).toBeTruthy();\n    expect(indexed.toSet().equals(Set<number>([1, 2, 3]))).toBeTruthy();\n    expect(indexed.toStack().equals(Stack<number>([1, 2, 3]))).toBeTruthy();\n    \n    expect(keyed.toList().equals(List<number>([1, 2, 3]))).toBeTruthy();\n    expect(keyed.toSet().equals(Set<number>([1, 2, 3]))).toBeTruthy();\n    expect(keyed.toStack().equals(Stack<number>([1, 2, 3]))).toBeTruthy();\n    \n    // {1..}\n    expect(set.toMap().equals(Map<number, number>([[1, 1], [2, 2], [3, 3]]))).toBeTruthy();\n    expect(set.toList().equals(List<number>([1, 2, 3]))).toBeTruthy();\n    expect(set.toStack().equals(Stack<number>([1, 2, 3]))).toBeTruthy();\n  });\n  \n  it('Conversion to Seq', () => {\n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    const set: Collection.Set<number> = Set<number>([1, 2, 3]);\n    \n    // {0..}\n    // 같지만 equals는 false로 나온다\n    //console.log('Collection.test.ts..()', indexed.toKeyedSeq(), Seq.Keyed<number, number>([[0, 1], [1, 2], [2, 3]]));\n    //expect(indexed.toKeyedSeq().equals(Seq.Keyed<number, number>([[0, 1], [1, 2], [2, 3]]))).toBeTruthy();\n    expect(indexed.toSetSeq().equals(Seq.Set<number>([1, 2, 3]))).toBeTruthy();\n    \n    expect(keyed.toIndexedSeq().equals(Seq.Indexed<number>([1, 2, 3]))).toBeTruthy();\n    expect(keyed.toSetSeq().equals(Seq.Set<number>([1, 2, 3]))).toBeTruthy();\n    \n    // {1..}\n    // 같지만 equals는 false로 나온다\n    //console.log('Collection.test.ts..()', set.toKeyedSeq(), Seq.Keyed<number, number>([[1, 1], [2, 2], [3, 3]]));\n    //expect(set.toKeyedSeq().equals(Seq.Keyed<number, number>([[1, 1], [2, 2], [3, 3]]))).toBeTruthy();\n    expect(set.toIndexedSeq().equals(Seq.Indexed<number>([1, 2, 3]))).toBeTruthy();\n  });\n  \n  it('Sequence algorithms', () => {\n    // map, filter, sort 모두 잘 작동된다.\n    // 사용에 주저할 필요가 없다. 심리적인 장벽을 허물자.\n    \n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    \n    expect(\n      indexed\n        .map<string>((v: number) => 'a' + v)\n        .equals(List<string>(['a1', 'a2', 'a3'])),\n    ).toBeTruthy();\n    \n    expect(\n      indexed\n        .filter((v: number) => v > 2)\n        .equals(List<number>([3])),\n    ).toBeTruthy();\n    \n    expect(\n      indexed\n        .filterNot((v: number) => v > 2)\n        .equals(List<number>([1, 2])),\n    ).toBeTruthy();\n    \n    expect(indexed.reverse().equals(List<number>([3, 2, 1]))).toBeTruthy();\n    \n    expect(\n      indexed\n        .sort((a: number, b: number) => a > b ? -1 : 1)\n        .equals(List<number>([3, 2, 1])),\n    ).toBeTruthy();\n    \n    // Value Mapper를 사용해서 비교가 될 숫자를 도출할 수 있다.\n    // 손에 익히면 도움이 많이 될 것 같다\n    expect(\n      List<{a: number}>([{a: 1}, {a: 2}, {a: 3}])\n        .sortBy<number>(\n          (v: {a: number}) => v.a,\n          (a: number, b: number) => a > b ? -1 : 1,\n        )\n        .toArray(),\n    ).toEqual([{a: 3}, {a: 2}, {a: 1}]);\n    \n    // 특정 V를 바탕으로 Group을 만드는 작업. 의외로 도움이 많이 될 것 같다.\n    expect(\n      List<{c: string, a: number}>([\n        {c: 'red', a: 1},\n        {c: 'red', a: 2},\n        {c: 'blue', a: 3},\n        {c: 'red', a: 4},\n        {c: 'blue', a: 5},\n      ])\n        .groupBy<string>((v: {c: string, a: number}) => v.c)\n        .toJS(),\n    ).toEqual({\n      red: [\n        {c: 'red', a: 1},\n        {c: 'red', a: 2},\n        {c: 'red', a: 4},\n      ],\n      blue: [\n        {c: 'blue', a: 3},\n        {c: 'blue', a: 5},\n      ],\n    });\n    \n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    \n    expect(\n      keyed\n        .map<string>((v: number, k: string) => k + v)\n        .equals(Map<string>({a: 'a1', b: 'b2', c: 'c3'})),\n    ).toBeTruthy();\n    \n    expect(\n      keyed\n        .filter((v: number, k: string) => v > 1)\n        .equals(Map<number>({b: 2, c: 3})),\n    ).toBeTruthy();\n    \n    expect(\n      keyed\n        .filterNot((v: number, k: string) => v > 1)\n        .equals(Map<number>({a: 1})),\n    ).toBeTruthy();\n    \n    expect(\n      keyed\n        .reverse()\n        .equals(keyed),\n    ).toBeTruthy();\n    // Collection.Keyed 역시 reverse(), sort(), sortBy() 가 작동하지만 특별한 의미가 없다\n    \n    // Indexed와는 다르게 하위 리스트가 Keyed가 된다\n    expect(\n      Map<{c: string, v: number}>({\n        a: {c: 'red', v: 1},\n        b: {c: 'blue', v: 2},\n        c: {c: 'red', v: 3},\n        d: {c: 'blue', v: 4},\n        e: {c: 'red', v: 5},\n      })\n        .groupBy<string>((v: {c: string, v: number}) => v.c)\n        .toJS(),\n    ).toEqual({\n      red: {\n        a: {c: 'red', v: 1},\n        c: {c: 'red', v: 3},\n        e: {c: 'red', v: 5},\n      },\n      blue: {\n        b: {c: 'blue', v: 2},\n        d: {c: 'blue', v: 4},\n      },\n    });\n  });\n  \n  it('Side Effect', () => {\n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    const set: Collection.Set<number> = Set<number>([1, 2, 3]);\n    \n    indexed.forEach((v: number, k: number, iter: Collection<number, number>) => {\n      expect(typeof v).toEqual('number');\n      expect(typeof k).toEqual('number');\n      expect(iter).toEqual(indexed);\n    });\n    \n    keyed.forEach((v: number, k: string, iter: Collection.Keyed<string, number>) => {\n      expect(typeof v).toEqual('number');\n      expect(typeof k).toEqual('string');\n      expect(iter).toEqual(keyed);\n    });\n    \n    set.forEach((v: number, k: number, iter: Collection.Set<number>) => {\n      expect(typeof v).toEqual('number');\n      expect(typeof k).toEqual('number');\n      expect(iter).toEqual(set);\n    });\n  });\n  \n  it('Creating Subsets', () => {\n    // 순서를 기준으로 하기 때문에 Keyed나 Set은 의미가 없을 것 같다.\n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    \n    // 잘라내기\n    expect(indexed.slice(2).equals(List<number>([3]))).toBeTruthy();\n    // 처음을 제외\n    expect(indexed.rest().equals(List<number>([2, 3]))).toBeTruthy();\n    // 마지막을 제외\n    expect(indexed.butLast().equals(List<number>([1, 2]))).toBeTruthy();\n    \n    // 앞의 몇 개를 제외한 나머지\n    expect(indexed.skip(2).equals(List([3]))).toBeTruthy();\n    // 뒤의 몇 개를 제외한 나머지\n    expect(indexed.skipLast(2).equals(List([1]))).toBeTruthy();\n    // false 조건이 나온 이후의 것들\n    expect(\n      indexed\n        .skipWhile((v: number) => v < 2)\n        .equals(List<number>([2, 3])),\n    ).toBeTruthy();\n    // true 조건이 나온 이후의 것들\n    expect(\n      indexed\n        .skipUntil((v: number) => v > 2)\n        .equals(List<number>([3])),\n    ).toBeTruthy();\n    \n    // skip* 보다는 take*가 좀 더 자연스러운 논리를 가진다.\n    // 건너뛰기 논리를 가진 skip* 보다는 take를 우선 사용할 일이 더 많을 것 같다.\n    \n    // 앞의 몇 개\n    expect(indexed.take(2).equals(List<number>([1, 2]))).toBeTruthy();\n    // 뒤의 몇 개\n    expect(indexed.takeLast(2).equals(List<number>([2, 3]))).toBeTruthy();\n    // false 조건이 나올때까지 가져온다\n    expect(\n      indexed\n        .takeWhile((v: number) => v < 3)\n        .equals(List<number>([1, 2])),\n    ).toBeTruthy();\n    // true 조건이 나올때까지 가져온다\n    expect(\n      indexed\n        .takeUntil((v: number) => v > 1)\n        .equals(List<number>([1])),\n    ).toBeTruthy();\n  });\n  \n  it('Combination', () => {\n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    \n    // 다른 List를 concat 할 수 있고\n    expect(\n      indexed\n        .concat(List<number>([4, 5]), List<number>([6, 7]))\n        .equals(List<number>([1, 2, 3, 4, 5, 6, 7])),\n    ).toBeTruthy();\n    \n    // Array도 가능\n    expect(\n      indexed\n        .concat([4, 5], [6, 7])\n        .equals(List<number>([1, 2, 3, 4, 5, 6, 7])),\n    ).toBeTruthy();\n    \n    // Push처럼 넣을 수도 있고\n    expect(\n      indexed\n        .concat(4, 5, 6, 7)\n        .equals(List<number>([1, 2, 3, 4, 5, 6, 7])),\n    ).toBeTruthy();\n    \n    // Collection.Keyed를 넣을 경우 V값들만 사용해서 합친다\n    expect(\n      indexed\n        .concat(Map<number>({a: 4, b: 5}).values())\n        .equals(List<number>([1, 2, 3, 4, 5])),\n    ).toBeTruthy();\n    \n    // Collection.Keyed에는 [K, V] 형태의 값들만 concat 할 수 있다\n    expect(\n      keyed\n        .concat(Map<number>({d: 4, e: 5}), Map<number>({f: 6}))\n        .equals(Map<number>({a: 1, b: 2, c: 3, d: 4, e: 5, f: 6})),\n    ).toBeTruthy();\n    \n    // object도 가능\n    expect(\n      keyed\n        .concat({d: 4, e: 5}, {f: 6})\n        .equals(Map<number>({a: 1, b: 2, c: 3, d: 4, e: 5, f: 6})),\n    ).toBeTruthy();\n    \n    // 계층형 List를 평판화 시킨다\n    expect(\n      (fromJS([[1, 2, 3], [4, 5, 6], [7, 8]]) as List<List<number>>) // of List<List<number>>\n        .flatten()\n        .equals(List<number>([1, 2, 3, 4, 5, 6, 7, 8])),\n    ).toBeTruthy();\n    \n    // Depth가 깊은 Tree들도 합친다\n    type ListTreeValue = (number | ListTree);\n    \n    interface ListTree extends List<ListTreeValue> {\n    }\n    \n    expect(\n      (fromJS([[[1, 2], [3]], [[4], [5, [6]]], [7, 8]]) as ListTree) // of List<...<number>>\n        .flatten()\n        .equals(List<number>([1, 2, 3, 4, 5, 6, 7, 8])),\n    ).toBeTruthy();\n    \n    // Shallow Depth = 1\n    expect(\n      (fromJS([[[1, 2], [3]], [[4, 5], [6]], [[7, 8]]]) as ListTree) // of List<List<List<number>>>\n        .flatten(true) // shallow = depth 1\n        .toJS(),\n    ).toEqual([[1, 2], [3], [4, 5], [6], [7, 8]]);\n    \n    // Depth 지정이 가능\n    expect(\n      (fromJS([[[1, 2], [3]], [[4, 5], [6]], [[7, 8]]]) as ListTree) // of List<List<List<number>>>\n        .flatten(1)\n        .toJS(),\n    ).toEqual([[1, 2], [3], [4, 5], [6], [7, 8]]);\n    \n    expect(\n      (fromJS([[[1, 2], [3]], [[4, 5], [6]], [[7, 8]]]) as ListTree) // of List<List<List<number>>>\n        .flatten(2)\n        .toJS(),\n    ).toEqual([1, 2, 3, 4, 5, 6, 7, 8]);\n    \n    // [K, V] Tree의 경우 최종적인 Leaf만 가져와서 flatten() 시킨다\n    type MapTreeValue = (number | MapTree);\n    \n    interface MapTree extends Map<string, MapTreeValue> {\n    }\n    \n    expect(\n      (fromJS({a: {a1: 1, a2: 2}, b: {b1: 1, b2: 2}}) as MapTree)\n        .flatten()\n        .toJS(),\n    ).toEqual({a1: 1, a2: 2, b1: 1, b2: 2});\n    \n    expect(\n      (fromJS({a: {a1: {a11: 3, a12: {a121: 1}}, a2: 2}, b: {b1: 1, b2: 2}}) as MapTree)\n        .flatten()\n        .toJS(),\n    ).toEqual({a11: 3, a121: 1, a2: 2, b1: 1, b2: 2});\n    \n    // flatMap은 map().flatten(1) 과 같다. 그리 사용할 케이스가 많다고 보긴 어려울 것 같다.\n    expect(\n      (fromJS([[1, 2, 3], [4, 5, 6], [7, 8]]) as ListTree) // of List<List<number>>\n        .flatMap((v: List<number>) => {\n          return v.map((x: number) => 'a' + x);\n        })\n        .equals(List<string>(['a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8'])),\n    ).toBeTruthy();\n  });\n  \n  it('Search for value', () => {\n    // K 기준, V 기준 검색이 모두 가능하고,\n    // 돌려받을 값도 K, V, [K, V] 모두 가능\n    \n    const indexed: Collection<number, number> = List<number>([1, 2, 3]) as Collection<number, number>;\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    \n    expect(indexed.find(\n      (v: number) => v === 2,\n    )).toEqual(2);\n    \n    expect(indexed.find(\n      (v: number) => v === 6,\n      null,\n      10,\n    )).toEqual(10);\n    \n    expect(indexed.findLast(\n      (v: number) => v === 3,\n    )).toEqual(3);\n    \n    expect(indexed.findEntry(\n      (v: number) => v === 2,\n    )).toEqual([1, 2]);\n    \n    expect(indexed.findEntry(\n      (v: number) => v === 6,\n      null,\n      10,\n    )).toEqual(10); // notSetValue가 [-1, 10]이 아니라 10으로 들어온다. 문제 많음\n    \n    expect(indexed.findLastEntry(\n      (v: number) => v === 3,\n    )).toEqual([2, 3]);\n    \n    expect(indexed.findKey(\n      (v: number) => v === 2,\n    )).toEqual(1);\n    \n    expect(indexed.findKey(\n      (v: number) => v === 6,\n    )).toEqual(undefined);\n    \n    // (V) => K    V를 넣어서 K를 가져온다\n    expect(indexed.keyOf(2)).toEqual(1);\n    expect(indexed.lastKeyOf(3)).toEqual(2);\n    \n    expect(indexed.maxBy<number>(\n      (v: number) => v === 2 ? 100 : v,\n    )).toEqual(2);\n    \n    expect(\n      List<{a: number}>([{a: 1}, {a: 2}, {a: 3}])\n        .maxBy<number>((v: {a: number}) => v.a),\n    ).toEqual({a: 3});\n    \n    expect(keyed.find(\n      (v: number) => v === 2,\n    )).toEqual(2);\n    \n    expect(keyed.keyOf(2)).toEqual('b');\n  });\n  \n  it('Comparison', () => {\n    // 전체와 부분을 비교할 수 있다.\n    // 집합 문제를 다룰때 도움이 되겠다.\n    \n    expect(\n      List<number>([2, 3, 4])\n        .isSubset(List<number>([1, 2, 3, 4, 5, 6, 7])),\n    ).toBeTruthy();\n    \n    expect(\n      List<number>([2, 3, 4])\n        .isSubset([1, 2, 3, 4, 5, 6, 7]),\n    ).toBeTruthy();\n    \n    expect(\n      List<number>([1, 2, 3, 4, 5, 6, 7])\n        .isSuperset(List<number>([2, 3, 4])),\n    ).toBeTruthy();\n    \n    expect(\n      List<number>([1, 2, 3, 4, 5, 6, 7])\n        .isSuperset([2, 3, 4]),\n    ).toBeTruthy();\n    \n    //expect(\n    //  Map<number>({c: 3, d: 4})\n    //    .isSubset(Map<number>({a: 1, b: 2, c: 3, d: 4, e: 5})),\n    //).toBeTruthy();\n    \n    // 비교 대상이 Iterable이다 보니 Collection.Keyed와 비교할 수 없다.\n    // Collection.Keyed에서는 사용하기 애매하겠다.\n    \n    expect(\n      Map<number>({c: 3, d: 4})\n        .isSubset([1, 2, 3, 4, 5]),\n    ).toBeTruthy();\n  });\n});"},function(e,n){e.exports="import { Collection, isIndexed, isKeyed, List } from 'immutable';\n\ndescribe('Collection.Indexed', () => {\n  //it('Conversion to Seq', () => {\n  //  // ???? 뭔 ㅆㅂ 에러만 나네\n  //  const indexed: Collection.Indexed<number> = List<number>([1, 2, 3, 4]);\n  //  console.log('Collection.Indexed.test.ts..()', indexed.fromEntrySeq());\n  //});\n  \n  it('Combination', () => {\n    const indexed: Collection.Indexed<number | string> = List<number>([1, 2, 3, 4]);\n    \n    // 모든 Item들의 중간에 특정 값을 끼워넣는다\n    // String Rows 처리 등 이래저래 쓸만한 케이스가 있을듯 싶은데...\n    expect(\n      indexed\n        .interpose('/')\n        .toJS(),\n    ).toEqual([1, '/', 2, '/', 3, '/', 4]);\n    \n    // 추가된 Item들을 순차적으로 배열한다\n    // [0, 3, 6]\n    // [1, 4, 8]\n    // [2, 5, 9]\n    // 와 같은 순서가 된다.\n    // 추가적으로 최소 Item 숫자에 맞춰지기 때문에 3, 4와 9가 누락된다.\n    expect(\n      indexed\n        .interleave(\n          List<number>([7, 8, 9]) as Collection<number, number>,\n          List<number>([100, 200]) as Collection<number, number>,\n        )\n        .toJS(),\n    ).toEqual([1, 7, 100, 2, 8, 200]);\n    \n    // Array.splice()와 동일\n    expect(\n      indexed\n        .splice(2, 1)\n        .toJS(),\n    ).toEqual([1, 2, 4]);\n    \n    // Collection.Indexed.interleave()와 동일하지만\n    // 2차 배열로 값들을 묶어준다\n    // 누락룰은 동일\n    expect(\n      indexed\n        .zip(\n          List<number>([7, 8, 9]) as Collection<number, number>,\n          List<number>([100, 200]) as Collection<number, number>,\n        )\n        .toJS(),\n    ).toEqual([[1, 7, 100], [2, 8, 200]]);\n    \n    // Collection.Indexed.zip()과 유사하지만\n    // 2차 배열로 묶어버리는 zip()과 다르게 어떻게 묶을지 자의적으로 선택할 수 있다.\n    // Grid와 같은 2차 배열 Data에서 합계를 낸다거나 하는데 유용할 것 같다\n    expect(\n      indexed\n        .zipWith<string>(\n          (...values: (string | number)[]) => {\n            return values.join(':');\n          },\n          List<number>([100, 200]) as Collection<number, number>,\n          List<string>(['x', 'y']) as Collection<number, string>,\n          List<string>(['!', '@']) as Collection<number, string>,\n        )\n        .toJS(),\n    ).toEqual(['1:100:x:!', '2:200:y:@']);\n    \n    expect(\n      List<number>([1, 2, 3])\n        .zipWith<number>(\n          (...values: number[]) => {\n            return values.reduce((sum: number, v: number) => sum + v, 0);\n          },\n          List<number>([10, 20, 30]) as Collection<number, number>,\n          List<number>([100, 200, 300]) as Collection<number, number>,\n          List<number>([1000, 2000, 3000]) as Collection<number, number>,\n        )\n        .toJS(),\n    ).toEqual([1111, 2222, 3333]);\n  });\n  \n  it('Search for value', () => {\n    const indexed: Collection.Indexed<number | string> = List<number>([1, 2, 3, 4]);\n    \n    // Array.indexOf()와 동일한 것들\n    expect(indexed.indexOf(2)).toEqual(1);\n    expect(indexed.lastIndexOf(3)).toEqual(2);\n    expect(indexed.findIndex((v: number | string) => v === 2)).toEqual(1);\n    expect(indexed.findLastIndex((v: number | string) => v === 3)).toEqual(2);\n  });\n});"},function(e,n){e.exports="import { Collection, Map } from 'immutable';\n\ndescribe('Collection.Keyed', () => {\n  it('Sequence functions', () => {\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3, d: 4});\n    \n    // [K, V] 를 [V, K]로 역전 시킨다. Index 생성시에 도움이 될 것 같기도 하고...\n    expect(\n      keyed\n        .flip()\n        .equals(Map<number, string>([[1, 'a'], [2, 'b'], [3, 'c'], [4, 'd']])),\n    ).toBeTruthy();\n  });\n  \n  it('Sequence algorithms', () => {\n    const keyed: Collection.Keyed<string, number> = Map<number>({a: 1, b: 2, c: 3, d: 4});\n    \n    // K를 변조한다\n    expect(\n      keyed\n        .mapKeys((k: string) => 'x' + k)\n        .equals(Map<number>({xa: 1, xb: 2, xc: 3, xd: 4})),\n    ).toBeTruthy();\n    \n    // [K, V]를 모두 변조한다 (이게 의외로 쓸만할듯...)\n    expect(\n      keyed\n        .mapEntries((e: [string, number]) => ['x' + e[0], e[1] * 100])\n        .equals(Map<number>({xa: 100, xb: 200, xc: 300, xd: 400})),\n    ).toBeTruthy();\n  });\n});"},function(e,n){e.exports="import { List } from 'immutable';\n\ndescribe('List', () => {\n  it('Persistent changes', () => {\n    const list: List<number> = List<number>([1, 2, 3, 4]);\n    \n    expect(list.set(2, 100).toJS()).toEqual([1, 2, 100, 4]);\n    expect(list.set(4, 100).toJS()).toEqual([1, 2, 3, 4, 100]);\n    expect(list.set(5, 100).toJS()).toEqual([1, 2, 3, 4, undefined, 100]);\n    \n    expect(list.delete(0).toJS()).toEqual([2, 3, 4]);\n    expect(list.delete(2).toJS()).toEqual([1, 2, 4]);\n    expect(list.delete(5).toJS()).toEqual([1, 2, 3, 4]);\n    \n    expect(list.insert(2, 100).toJS()).toEqual([1, 2, 100, 3, 4]);\n    expect(list.insert(5, 100).toJS()).not.toEqual([1, 2, 3, 4, undefined, 100]);\n    expect(list.insert(5, 100).toJS()).toEqual([1, 2, 3, 4, 100]);\n    \n    expect(list.clear().size).toEqual(0);\n    \n    expect(list.push(5, 6).toJS()).toEqual([1, 2, 3, 4, 5, 6]);\n    expect(list.pop().toJS()).toEqual([1, 2, 3]);\n    \n    expect(list.unshift(5, 6).toJS()).toEqual([5, 6, 1, 2, 3, 4]);\n    expect(list.shift().toJS()).toEqual([2, 3, 4]);\n    \n    expect(\n      list\n        .update(2, (v: number) => v * 100)\n        .toJS(),\n    ).toEqual([1, 2, 300, 4]);\n    \n    expect(\n      list\n        .update(5, 9, (v: number) => v * 100)\n        .toJS(),\n    ).toEqual([1, 2, 3, 4, undefined, 900]);\n    \n    // concat()이 아니다. 같은 Index를 덮어쓰는 Merge다.\n    // ??? concat()이 되어버렸는데??? ㅆㅂ 이게 뭐야?\n    expect(\n      list\n        .merge(\n          List<number>([5, 6, 7]),\n          List<number>([100, 200]),\n        )\n        .toJS(),\n    ).toEqual([1, 2, 3, 4, 5, 6, 7, 100, 200]);\n    \n    //expect(\n    //  list\n    //    .mergeWith(\n    //      (oldVal, newVal) => {\n    //        return Math.max(oldVal, newVal);\n    //      },\n    //      List<number>([-1, -2, -3, -4, -5]),\n    //      List<number>([100, 200]),\n    //    )\n    //    .toJS(),\n    //).toEqual([100, 200, 3, 4, NaN]);\n  });\n  \n  //it('Deep persistent changes', () => {\n  //\n  //});\n});"},function(e,n){e.exports="import { fromJS, Map } from 'immutable';\nimport { AMap } from './Collection.test';\n\ndescribe('Map', () => {\n  it('Persistent changes', () => {\n    const map: Map<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    \n    expect(map.clear().size).toEqual(0);\n    expect(map.update('b', (b: number) => b * 100).get('b')).toEqual(200);\n    expect(map.update('z', 8, (z: number) => z * 100).get('z')).toEqual(800);\n    \n    expect(\n      map\n        .merge(Map<number>({d: 4, e: 5}))\n        .toJS(),\n    ).toEqual({a: 1, b: 2, c: 3, d: 4, e: 5});\n    \n    expect(\n      map\n        .merge({d: 4, e: 5})\n        .toJS(),\n    ).toEqual({a: 1, b: 2, c: 3, d: 4, e: 5});\n    \n    // Object.assign과 같다. 뒤에 오는 c가 최종 결과에 반영된다\n    expect(\n      map\n        .merge({c: 100, d: 4, e: 5})\n        .toJS(),\n    ).toEqual({a: 1, b: 2, c: 100, d: 4, e: 5});\n    \n    expect(\n      map\n        .mergeWith(\n          ((oldVal: number, newVal: number, k: string) => {\n            return oldVal > newVal ? oldVal : newVal; // 2. 중복을 어떻게 처리할지 결정한다\n          }),\n          {c: 100, d: 4, e: 5}, // 1. 입력된 값들 중 중복값이 있으면\n          {c: 300},\n          {c: 1000}, // 3. 중복된 값이 여러번이면 여러번 실행된다\n        )\n        .toJS(),\n    ).toEqual({a: 1, b: 2, c: 1000, d: 4, e: 5});\n  });\n  \n  it('Transient changes', () => {\n    const map: Map<string, number> = Map<number>({a: 1, b: 2, c: 3});\n    const tree: AMap = fromJS({\n      a: 'a-1',\n      children: [\n        {\n          b: 'b-11',\n          children: [\n            {c: 'c-111'},\n            {c: 'c-112'},\n          ],\n        },\n      ],\n    });\n    \n    // Mutable... 대입해서 새로운 instance을 저장하지 않아도 된다.\n    // Bulk update를 칠때 도움이 될 것 같다.\n    expect(\n      map\n        .withMutations((mutable: Map<string, number>) => {\n          mutable.set('a', 100);\n          mutable.set('c', 300);\n          return mutable;\n        })\n        .toJS(),\n    ).toEqual({\n      a: 100,\n      b: 2,\n      c: 300,\n    });\n    \n    // Tree 때문에 고민하지 말고 그냥 setIn()을 사용하면 되겠다\n    expect(\n      tree\n        .withMutations((mutable: AMap) => {\n          mutable.set('a', 'a-2');\n          mutable.setIn(['children', 0, 'children', 1, 'c'], 'c-xxx');\n          return mutable;\n        })\n        .toJS(),\n    ).toEqual({\n      a: 'a-2',\n      children: [\n        {\n          b: 'b-11',\n          children: [\n            {c: 'c-111'},\n            {c: 'c-xxx'},\n          ],\n        },\n      ],\n    });\n  });\n});"},function(e,n){e.exports="import { List, Stack } from 'immutable';\n\n// 후입선출 (LIFO) 구조 - 마지막에 들어간게 제일 먼저 나온다\ndescribe('Stack', () => {\n  it('Reading values', () => {\n    const stack: Stack<number> = Stack<number>([1, 2, 3, 4]);\n    \n    // Collection.first()와 동일\n    expect(stack.peek()).toEqual(1);\n  });\n  \n  it('Persistent changes', () => {\n    const stack: Stack<number> = Stack<number>([1, 2, 3, 4]);\n    \n    expect(stack.clear().size).toEqual(0);\n    \n    // Stack 구조이기 때문에 push, pushAll, pop은 없는 개념이다\n    // 앞대가리로 집어넣고, peek()으로 꺼내거나 shift()로 제거한다\n    expect(stack.unshift(5, 6).toJS()).toEqual([5, 6, 1, 2, 3, 4]);\n    expect(stack.push(5, 6).toJS()).toEqual([5, 6, 1, 2, 3, 4]);\n    \n    expect(stack.unshiftAll(List<number>([5, 6])).toJS()).toEqual([5, 6, 1, 2, 3, 4]);\n    expect(stack.pushAll(List<number>([5, 6])).toJS()).toEqual([5, 6, 1, 2, 3, 4]);\n    \n    expect(stack.shift().toJS()).toEqual([2, 3, 4]);\n    expect(stack.pop().toJS()).toEqual([2, 3, 4]);\n  });\n});"},function(e,n){e.exports="import { fromJS, Map } from 'immutable';\nimport { AMap } from './Collection.test';\n\ndescribe('Tree', () => {\n  it('Persistent changes', () => {\n    // 복잡한 Tree를 merge 할 수 있다.\n    // 깊은 수준까지 적용이 된다는게 편할 것 같다.\n    expect(\n      (fromJS({\n        a: 1,\n        b: {\n          b1: 10,\n        },\n      }) as Map<string, number | object>)\n        .mergeDeep(fromJS({\n          a: {\n            a1: 1,\n          },\n          b: {\n            b2: 100,\n            b3: {\n              b31: 1,\n            },\n          },\n          c: 10,\n        }))\n        .toJS(),\n    ).toEqual({\n      a: {\n        a1: 1,\n      },\n      b: {\n        b1: 10,\n        b2: 100,\n        b3: {\n          b31: 1,\n        },\n      },\n      c: 10,\n    });\n    \n    // 깊은 수준의 비교를 지원해준다\n    // K가 Array로 왔으면 더 좋았을 것 같은데... 아쉽네...\n    // 복잡한 구조체의 Combine이 필요한 경우 (ex. Tree의 일부 값이 변경되는 경우?) 유용할 것 같다.\n    // 1. {} 와 {} 의 경우에는 자동으로 합친다\n    // 2. V 와 V 가 충돌하는 경우 알린다\n    // 3. V 와 {} 가 충돌하는 경우 알린다\n    expect(\n      (fromJS({\n        a: {\n          a1: 10,\n          a2: 3,\n        },\n        b: {\n          b1: 10,\n          b3: {\n            b31: 100,\n          },\n        },\n      }) as Map<string, number | object>)\n        .mergeDeepWith(\n          (oldVal: number | object, newVal: number | object, k: string) => {\n            // a1 10 1\n            // a2 3 Map { \"a21\": 3 }\n            // b31 100 1\n            return typeof oldVal === 'number' && typeof newVal === 'number'\n              ? oldVal > newVal\n                ? oldVal\n                : newVal\n              : newVal;\n          },\n          fromJS({\n            a: {\n              a1: 1,\n              a2: {\n                a21: 3,\n              },\n            },\n            b: {\n              b2: 100,\n              b3: {\n                b31: 1,\n              },\n            },\n            c: 10,\n          }))\n        .toJS(),\n    ).toEqual({\n      a: {\n        a1: 10,\n        a2: {\n          a21: 3,\n        },\n      },\n      b: {\n        b1: 10,\n        b2: 100,\n        b3: {\n          b31: 100,\n        },\n      },\n      c: 10,\n    });\n  });\n  \n  it('Deep persistent changes', () => {\n    const tree: AMap = fromJS({\n      a: 'a-1',\n      children: [\n        {\n          b: 'b-11',\n          children: [\n            {c: 'c-111'},\n            {c: 'c-112'},\n          ],\n        },\n      ],\n    });\n    \n    expect(\n      tree\n        .setIn(['children', 0, 'children', 0, 'd'], 100)\n        .getIn(['children', 0, 'children', 0, 'd']),\n    ).toEqual(100);\n    \n    expect(\n      tree\n        .setIn(['children', 0, 'children', 0, 'c'], 'c-xxx')\n        .getIn(['children', 0, 'children', 0, 'c']),\n    ).toEqual('c-xxx');\n    \n    expect(\n      tree\n        .deleteIn(['children', 0, 'children', 0, 'c'])\n        .getIn(['children', 0, 'children', 0, 'c']),\n    ).toBeUndefined();\n    \n    // Indexed를 지우면 밀려서 올라온다\n    expect(\n      tree\n        .deleteIn(['children', 0, 'children', 0])\n        .getIn(['children', 0, 'children', 0, 'c']),\n    ).toEqual('c-112');\n    \n    expect(\n      tree\n        .updateIn(['children', 0, 'children', 0, 'c'], (c: string) => c + '!!!')\n        .getIn(['children', 0, 'children', 0, 'c']),\n    ).toEqual('c-111!!!');\n    \n    // 특정 Key Path를 기준으로 Merge를 작동시킨다\n    // 일정 영역의 데이터를 Update 할 때 도움이 될 것 같다.\n    // Deep이 아니기 때문에 특정 Key Path의 1단계만 Merge 된다\n    expect(\n      (fromJS({\n        a: {\n          a1: 1,\n        },\n        b: {\n          b2: 100,\n          b3: {\n            b31: 1,\n            b32: 5,\n            b33: {\n              b332: 10,\n              b333: 4,\n            },\n          },\n        },\n        c: 10,\n      }) as Map<string, number | object>)\n        .mergeIn(\n          ['b', 'b3'],\n          fromJS({\n            b31: 100,\n            b33: {\n              b334: 100,\n            },\n          }),\n        )\n        .toJS(),\n    ).toEqual({\n      a: {\n        a1: 1,\n      },\n      b: {\n        b2: 100,\n        b3: {\n          b31: 100,\n          b32: 5,\n          b33: {\n            b334: 100,\n          },\n        },\n      },\n      c: 10,\n    });\n    \n    // Deep이 적용된다\n    expect(\n      (fromJS({\n        a: {\n          a1: 1,\n        },\n        b: {\n          b2: 100,\n          b3: {\n            b31: 1,\n            b32: 5,\n            b33: {\n              b332: 10,\n              b333: 4,\n            },\n          },\n        },\n        c: 10,\n      }) as Map<string, number | object>)\n        .mergeDeepIn(\n          ['b', 'b3'],\n          fromJS({\n            b31: 100,\n            b33: {\n              b334: 100,\n            },\n          }),\n        )\n        .toJS(),\n    ).toEqual({\n      a: {\n        a1: 1,\n      },\n      b: {\n        b2: 100,\n        b3: {\n          b31: 100,\n          b32: 5,\n          b33: {\n            b332: 10,\n            b333: 4,\n            b334: 100,\n          },\n        },\n      },\n      c: 10,\n    });\n  });\n});"},function(e,n,t){"use strict";t.r(n);var r=t(0),o=t.n(r),a=t(1);n.default=function(){return o.a.createElement("div",null,o.a.createElement(a.b,{text:t(78)}),o.a.createElement(a.a,{value:t(79),language:"typescript"}))}},function(e,n){e.exports="# numeral"},function(e,n){e.exports="import numeral from 'numeral';\n\ndescribe('numeral', () => {\n  it('Number formatting', () => {\n    // ---------------------------------------------\n    // 정수, 소숫점 지정\n    // ---------------------------------------------\n    expect(numeral(1000.23423).format('0,0')).toEqual('1,000');\n    expect(numeral(1000.23423).format('0,0.0000')).toEqual('1,000.2342');\n    expect(numeral(1000).format('0,0.0000')).toEqual('1,000.0000');\n    // 소수가 없으면 출력 안함\n    expect(numeral(1000).format('0,0.[0000]')).toEqual('1,000');\n    // 소수가 지정보다 많으면 잘라냄\n    expect(numeral(1000.23423).format('0,0.[000]')).toEqual('1,000.234');\n    // 소수가 지정보다 적으면 그대로 출력\n    expect(numeral(1000.2).format('0,0.[000]')).toEqual('1,000.2');\n    \n    // ---------------------------------------------\n    // 특수 표시\n    // ---------------------------------------------\n    // +, - 표시\n    expect(numeral(100).format('+0,0')).toEqual('+100');\n    expect(numeral(-100).format('+0,0')).toEqual('-100');\n    // surffix unit - k, m, b, t\n    expect(numeral(12).format('0a')).toEqual('12');\n    expect(numeral(1234).format('0a')).toEqual('1k');\n    expect(numeral(1234567).format('0a')).toEqual('1m');\n    expect(numeral(1234567890).format('0a')).toEqual('1b');\n    expect(numeral(1234567890000).format('0a')).toEqual('1t');\n    expect(numeral(12345678900000000).format('0a')).toEqual('12346t');\n    expect(numeral(1234).format('0.0a')).toEqual('1.2k');\n    expect(numeral(1234).format('0.00a')).toEqual('1.23k');\n    expect(numeral(1000).format('0.0a')).toEqual('1.0k');\n    expect(numeral(1000).format('0.[0]a')).toEqual('1k');\n    // surffix unit - 1st\n    expect(numeral(1).format('0o')).toEqual('1st');\n    expect(numeral(2).format('0o')).toEqual('2nd');\n    expect(numeral(10).format('0o')).toEqual('10th');\n    // bytes\n    expect(numeral(100).format('0b')).toEqual('100B');\n    expect(numeral(1024).format('0b')).toEqual('1KB');\n    expect(numeral(1024).format('0.0b')).toEqual('1.0KB');\n    // percentage\n    expect(numeral(1).format('0%')).toEqual('100%');\n    expect(numeral(0.987).format('0%')).toEqual('99%');\n    expect(numeral(0.98764).format('0.00%')).toEqual('98.76%');\n    expect(numeral(0.9).format('0.[000]%')).toEqual('90%');\n    expect(numeral(0.98282738).format('0.[000]%')).toEqual('98.283%');\n    \n    // ---------------------------------------------\n    // Custom\n    // ---------------------------------------------\n    // zero, null format\n    numeral.zeroFormat('###');\n    numeral.nullFormat('N/A');\n    expect(numeral(0).format('0')).toEqual('###');\n    expect(numeral(null).format('0')).toEqual('N/A');\n    // undefined는 0으로 취급된다?\n    expect(numeral(undefined).format('0')).toEqual('###');\n    // 전역적으로 변경해야만 한다. (왜?)\n    numeral.zeroFormat('-');\n    numeral.nullFormat('-');\n    expect(numeral(0).format('0')).toEqual('-');\n    expect(numeral(null).format('0')).toEqual('-');\n    expect(numeral(undefined).format('0')).toEqual('-');\n    \n    numeral.register('format', 'half', {\n      regexps: {\n        format: /(half)/,\n        unformat: /(half)/,\n      },\n      format: (value: number, format: string, roundingFunction: RoundingFunction) => {\n        // numberToFormat()은 문자를 무시한 format string을 보내준다\n        // @ts-ignore typings에 _ 정의되지 않았음\n        return numeral._.numberToFormat(value / 2, format, roundingFunction) + 'half';\n      },\n      unformat: (text: string) => {\n        // stringToNumber()는 문자를 무시한 number를 보내준다\n        // @ts-ignore typings에 _ 정의되지 않았음\n        return numeral._.stringToNumber(text) * 2;\n      },\n    });\n    \n    expect(numeral(100).format('0half')).toEqual('50half');\n    expect(numeral('51half').value()).toEqual(102);\n  });\n});"},function(e,n,t){"use strict";t.r(n);var r=t(0),o=t.n(r),a=t(1),i=t(11),l=t.n(i);function u(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},r=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.forEach(function(n){s(e,n,t[n])})}return e}function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function c(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function p(e,n){return!n||"object"!=typeof n&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function m(e){return(m=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function d(e,n){return(d=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var b=function(e){function n(e){var t;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(t=p(this,m(n).call(this,e))).container=Object(r.createRef)(),t.thumb=Object(r.createRef)(),t.track=Object(r.createRef)(),t.cursorStart=0,t.thumbStart=0,t.thumbMaximum=0,t.containerHeight=0,t.resizeObserver=void 0,t.resizeHandler=function(e){var n=!0,r=!1,o=void 0;try{for(var a,i=e[Symbol.iterator]();!(n=(a=i.next()).done);n=!0){var l=a.value;l.target===t.container.current&&l.contentRect.height!==t.containerHeight&&(t.containerHeight=l.contentRect.height,t.updateScroll())}}catch(e){r=!0,o=e}finally{try{n||null==i.return||i.return()}finally{if(r)throw o}}},t.updateScroll=function(){var e=t.props,n=e.contentHeight,r=e.viewportHeight,o=e.marginTop,a=e.marginBottom,i=e.scrollPosition,l=t.state,s=l.containerStyle,c=l.thumbStyle,p=l.trackStyle;if(n>r){var m=t.containerHeight-o-a,d=r/n*m,b=i/n*m;t.setState({containerStyle:u({},s,{visibility:"visible"}),thumbStyle:u({},c,{display:"block",top:b+o,height:d}),trackStyle:u({},p,{display:"block",top:o,bottom:a})})}else t.setState({containerStyle:u({},s,{visibility:"hidden"}),thumbStyle:u({},c,{display:"none"}),trackStyle:u({},p,{display:"none"})})},t.onMouseDown=function(e){t.cursorStart=e.screenY,t.thumbStart=t.thumb.current.offsetTop-t.props.marginTop,t.thumbMaximum=t.track.current.clientHeight-t.thumb.current.clientHeight,window.addEventListener("mouseup",t.onMouseUp),window.addEventListener("mousemove",t.onMouseMove),"function"==typeof t.props.onScrollEnter&&t.props.onScrollEnter(),e.stopPropagation()},t.onMouseUp=function(e){window.removeEventListener("mouseup",t.onMouseUp),window.removeEventListener("mousemove",t.onMouseMove),"function"==typeof t.props.onScrollLeave&&t.props.onScrollLeave(),e.stopPropagation()},t.onMouseMove=function(e){var n=e.screenY-t.cursorStart,r=t.thumbStart+n;r<0?r=0:r>t.thumbMaximum&&(r=t.thumbMaximum),t.setState({thumbStyle:u({},t.state.thumbStyle,{top:r+t.props.marginTop})});var o=r/t.track.current.clientHeight,a=t.props.contentHeight*o;t.props.onScroll(a,o)},t.resizeObserver=new l.a(t.resizeHandler),t.state={containerStyle:{position:"relative",visibility:"hidden"},thumbStyle:{position:"absolute",display:"none",left:0,right:0,top:e.marginTop,height:0},trackStyle:{position:"absolute",display:"none",left:0,right:0,top:e.marginTop,bottom:e.marginBottom}},t}var t,o,a;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&d(e,n)}(n,r["Component"]),t=n,(o=[{key:"render",value:function(){return this.props.children({containerRef:this.container,thumbRef:this.thumb,trackRef:this.track,containerStyle:this.state.containerStyle,thumbStyle:this.state.thumbStyle,trackStyle:this.state.trackStyle})}},{key:"componentDidMount",value:function(){if(!this.container.current||!this.thumb.current||!this.track.current)throw new Error("Did not assigned values to RefObject.current!");this.containerHeight=this.container.current.offsetHeight,this.resizeObserver.observe(this.container.current),this.thumb.current.addEventListener("mousedown",this.onMouseDown),this.updateScroll()}},{key:"getSnapshotBeforeUpdate",value:function(e){var n=this;return["marginTop","marginBottom","contentHeight","viewportHeight"].some(function(t){return n.props[t]!==e[t]})}},{key:"componentDidUpdate",value:function(e,n,t){t&&this.updateScroll()}},{key:"componentWillUnmount",value:function(){this.resizeObserver.disconnect()}}])&&c(t.prototype,o),a&&c(t,a),n}();function f(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},r=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.forEach(function(n){g(e,n,t[n])})}return e}function g(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function x(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function h(e,n){return!n||"object"!=typeof n&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function y(e){return(y=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function v(e,n){return(v=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}b.defaultProps={marginTop:0,marginBottom:0};var S=function(e){function n(e){var t;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(t=h(this,y(n).call(this,e))).container=Object(r.createRef)(),t.thumb=Object(r.createRef)(),t.track=Object(r.createRef)(),t.cursorStart=0,t.thumbStart=0,t.thumbMaximum=0,t.containerWidth=0,t.resizeObserver=void 0,t.resizeHandler=function(e){var n=!0,r=!1,o=void 0;try{for(var a,i=e[Symbol.iterator]();!(n=(a=i.next()).done);n=!0){var l=a.value;l.target===t.container.current&&l.contentRect.width!==t.containerWidth&&(t.containerWidth=l.contentRect.width,t.updateScroll())}}catch(e){r=!0,o=e}finally{try{n||null==i.return||i.return()}finally{if(r)throw o}}},t.updateScroll=function(){var e=t.props,n=e.contentWidth,r=e.viewportWidth,o=e.marginLeft,a=e.marginRight,i=e.scrollPosition,l=t.state,u=l.containerStyle,s=l.thumbStyle,c=l.trackStyle;if(n>r){var p=t.containerWidth-o-a,m=r/n*p,d=i/n*p;t.setState({containerStyle:f({},u,{visibility:"visible"}),thumbStyle:f({},s,{display:"block",left:d+o,width:m}),trackStyle:f({},c,{display:"block",left:o,right:a})})}else t.setState({containerStyle:f({},u,{visibility:"hidden"}),thumbStyle:f({},s,{display:"none"}),trackStyle:f({},c,{display:"none"})})},t.onMouseDown=function(e){t.cursorStart=e.screenX,t.thumbStart=t.thumb.current.offsetLeft-t.props.marginLeft,t.thumbMaximum=t.track.current.clientWidth-t.thumb.current.clientWidth,window.addEventListener("mouseup",t.onMouseUp),window.addEventListener("mousemove",t.onMouseMove),"function"==typeof t.props.onScrollEnter&&t.props.onScrollEnter(),e.stopPropagation()},t.onMouseUp=function(e){window.removeEventListener("mouseup",t.onMouseUp),window.removeEventListener("mousemove",t.onMouseMove),"function"==typeof t.props.onScrollLeave&&t.props.onScrollLeave(),e.stopPropagation()},t.onMouseMove=function(e){var n=e.screenX-t.cursorStart,r=t.thumbStart+n;r<0?r=0:r>t.thumbMaximum&&(r=t.thumbMaximum),t.setState({thumbStyle:f({},t.state.thumbStyle,{left:r+t.props.marginLeft})});var o=r/t.track.current.clientWidth,a=t.props.contentWidth*o;t.props.onScroll(a,o)},t.resizeObserver=new l.a(t.resizeHandler),t.state={containerStyle:{position:"relative",visibility:"hidden"},thumbStyle:{position:"absolute",display:"none",left:e.marginLeft,width:0,top:0,bottom:0},trackStyle:{position:"absolute",display:"none",left:e.marginLeft,right:e.marginRight,top:0,bottom:0}},t}var t,o,a;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&v(e,n)}(n,r["Component"]),t=n,(o=[{key:"render",value:function(){return this.props.children({containerRef:this.container,thumbRef:this.thumb,trackRef:this.track,containerStyle:this.state.containerStyle,thumbStyle:this.state.thumbStyle,trackStyle:this.state.trackStyle})}},{key:"componentDidMount",value:function(){if(!this.container.current||!this.thumb.current||!this.track.current)throw new Error("Did not assigned values to RefObject.current!");this.containerWidth=this.container.current.offsetWidth,this.resizeObserver.observe(this.container.current),this.thumb.current.addEventListener("mousedown",this.onMouseDown),this.updateScroll()}},{key:"getSnapshotBeforeUpdate",value:function(e){var n=this;return["marginLeft","marginRight","contentWidth","viewportWidth"].some(function(t){return n.props[t]!==e[t]})}},{key:"componentDidUpdate",value:function(e,n,t){t&&this.updateScroll()}},{key:"componentWillUnmount",value:function(){this.resizeObserver.disconnect()}}])&&x(t.prototype,o),a&&x(t,a),n}();function E(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},r=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.forEach(function(n){k(e,n,t[n])})}return e}function k(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function q(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=[],r=!0,o=!1,a=void 0;try{for(var i,l=e[Symbol.iterator]();!(r=(i=l.next()).done)&&(t.push(i.value),!n||t.length!==n);r=!0);}catch(e){o=!0,a=e}finally{try{r||null==l.return||l.return()}finally{if(o)throw a}}return t}(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function w(){var e=q(Object(r.useState)(Math.floor(3e4*Math.random())+1e4),2),n=e[0],t=e[1],a=q(Object(r.useState)(Math.floor(1e4*Math.random())+1e4),2),i=a[0],l=a[1],u=q(Object(r.useState)(0),2),s=u[0],c=u[1],p=q(Object(r.useState)(0),2),m=p[0],d=p[1],f=q(Object(r.useState)(250),2),g=f[0],x=f[1];return o.a.createElement("div",null,o.a.createElement("div",{style:{height:g}},o.a.createElement(b,{contentHeight:n,viewportHeight:i,scrollPosition:s,marginTop:15,marginBottom:15,onScroll:function(e,n){c(e),d(n)}},function(e){var n=e.containerRef,t=e.thumbRef,r=e.trackRef,a=e.containerStyle,i=e.thumbStyle,l=e.trackStyle;return o.a.createElement("div",{ref:n,style:E({},a,{width:10,height:"100%",backgroundColor:"rgba(0, 0, 0, 0.3)"})},o.a.createElement("div",{ref:r,style:E({},l,{left:-5,right:-5,backgroundColor:"rgba(0, 0, 0, 0.3)",border:"rgba(0, 0, 0, 1)"})}),o.a.createElement("div",{ref:t,style:E({},i,{left:-10,right:-10,backgroundColor:"rgba(0, 0, 0, 0.3)",border:"rgba(0, 0, 0, 1)"})}))})),o.a.createElement("ul",null,o.a.createElement("li",null,"scrollPosition: ",s),o.a.createElement("li",null,"scrollRatio: ",m),o.a.createElement("li",null,"contentHeight: ",n),o.a.createElement("li",null,"viewportHeight: ",i)),o.a.createElement("div",null,o.a.createElement("button",{onClick:function(){t(Math.floor(3e4*Math.random())+1e4),l(Math.floor(1e4*Math.random())+1e4),c(0),d(0)}},"set random values"),o.a.createElement("button",{onClick:function(){x(Math.floor(300*Math.random())+30)}},"set random container height")))}function C(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},r=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.forEach(function(n){L(e,n,t[n])})}return e}function L(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function T(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=[],r=!0,o=!1,a=void 0;try{for(var i,l=e[Symbol.iterator]();!(r=(i=l.next()).done)&&(t.push(i.value),!n||t.length!==n);r=!0);}catch(e){o=!0,a=e}finally{try{r||null==l.return||l.return()}finally{if(o)throw a}}return t}(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function M(){var e=T(Object(r.useState)(Math.floor(3e4*Math.random())+1e4),2),n=e[0],t=e[1],a=T(Object(r.useState)(Math.floor(1e4*Math.random())+1e4),2),i=a[0],l=a[1],u=T(Object(r.useState)(0),2),s=u[0],c=u[1],p=T(Object(r.useState)(0),2),m=p[0],d=p[1],b=T(Object(r.useState)(250),2),f=b[0],g=b[1];return o.a.createElement("div",null,o.a.createElement("div",{style:{width:f}},o.a.createElement(S,{contentWidth:n,viewportWidth:i,scrollPosition:s,marginLeft:15,marginRight:15,onScroll:function(e,n){c(e),d(n)}},function(e){var n=e.containerRef,t=e.thumbRef,r=e.trackRef,a=e.containerStyle,i=e.thumbStyle,l=e.trackStyle;return o.a.createElement("div",{ref:n,style:C({},a,{width:"100%",height:10,backgroundColor:"rgba(0, 0, 0, 0.3)"})},o.a.createElement("div",{ref:r,style:C({},l,{top:-5,bottom:-5,backgroundColor:"rgba(0, 0, 0, 0.3)",border:"rgba(0, 0, 0, 1)"})}),o.a.createElement("div",{ref:t,style:C({},i,{top:-10,bottom:-10,backgroundColor:"rgba(0, 0, 0, 0.3)",border:"rgba(0, 0, 0, 1)"})}))})),o.a.createElement("ul",null,o.a.createElement("li",null,"scrollPosition: ",s),o.a.createElement("li",null,"scrollRatio: ",m),o.a.createElement("li",null,"contentWidth: ",n),o.a.createElement("li",null,"viewportWidth: ",i)),o.a.createElement("div",null,o.a.createElement("button",{onClick:function(){t(Math.floor(3e4*Math.random())+1e4),l(Math.floor(1e4*Math.random())+1e4),c(0),d(0)}},"set random values"),o.a.createElement("button",{onClick:function(){g(Math.floor(300*Math.random())+30)}},"set random container width")))}function j(){return o.a.createElement("div",null,o.a.createElement("h1",null,"VerticalScroll"),o.a.createElement(w,null),o.a.createElement(a.a,{value:t(63),language:"tsx"}),o.a.createElement("h1",null,"HorizontalScroll"),o.a.createElement(M,null),o.a.createElement(a.a,{value:t(64),language:"tsx"}))}S.defaultProps={marginLeft:0,marginRight:0},t.d(n,"default",function(){return j})},function(e,n,t){"use strict";t.r(n);var r=t(0),o=t.n(r),a=t(1);function i(e){var n=Object(r.useMemo)(function(){if("string"==typeof e){var n=new RegExp("[".concat(e,"]"));return function(e){return n.test(e)}}if("function"==typeof e)return e;throw new Error("availableCharacters must be string or function")},[e]);return{onKeyPress:Object(r.useCallback)(function(e){n(e.key)||(e.preventDefault(),e.stopPropagation())},[])}}function l(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=[],r=!0,o=!1,a=void 0;try{for(var i,l=e[Symbol.iterator]();!(r=(i=l.next()).done)&&(t.push(i.value),!n||t.length!==n);r=!0);}catch(e){o=!0,a=e}finally{try{r||null==l.return||l.return()}finally{if(o)throw a}}return t}(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function u(){var e=i("abcd0-9").onKeyPress,n=l(Object(r.useState)(""),2),t=n[0],a=n[1],u=Object(r.useCallback)(function(e){a(e.target.value)},[a]);return o.a.createElement("div",null,o.a.createElement("input",{type:"text",value:t,onChange:u,onKeyPress:e}),o.a.createElement("p",null,'text is "',t,'"'))}function s(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=[],r=!0,o=!1,a=void 0;try{for(var i,l=e[Symbol.iterator]();!(r=(i=l.next()).done)&&(t.push(i.value),!n||t.length!==n);r=!0);}catch(e){o=!0,a=e}finally{try{r||null==l.return||l.return()}finally{if(o)throw a}}return t}(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var c=new Set(["a","b","c","d","1","2","3","@","#"]);function p(){var e=i(function(e){return c.has(e)}).onKeyPress,n=s(Object(r.useState)(""),2),t=n[0],a=n[1],l=Object(r.useCallback)(function(e){a(e.target.value)},[a]);return o.a.createElement("div",null,o.a.createElement("input",{type:"text",value:t,onChange:l,onKeyPress:e}),o.a.createElement("p",null,'text is "',t,'"'))}function m(){return o.a.createElement("div",null,o.a.createElement(a.b,{text:t(60)}),o.a.createElement("h1",null,"Sample"),o.a.createElement(u,null),o.a.createElement(a.a,{value:t(61),language:"tsx"}),o.a.createElement(p,null),o.a.createElement(a.a,{value:t(62),language:"tsx"}))}t.d(n,"default",function(){return m})}]));